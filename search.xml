<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Blink 适配 Hive 1.x</title>
    <url>/2019/Blink-%E9%80%82%E9%85%8D-Hive-1-x/</url>
    <content><![CDATA[<p>flink 是新一代的流式计算引擎，在 flink 的数据抽象里，数据都是流（stream），批数据就是有界的流（bounded stream），是流的特例，而 spark 所有的数据都是批数据（batch），spark 处理流数据是把流当作微批（micro batch）来处理，只能达到秒级别的准实时性。在数据处理的抽象程度上，flink 相比 spark 是更加先进的。当前许多公司已经用 flink 取代 spark streaming 和 storm 作为流计算引擎的首选。flink 目前正在高速发展中，接入更多的数据源，但是在 flink 的主分支上对 hive 的数据接入还没有完善的支持，只有一个没人维护的 hcatalog 模块，blink 作为阿里的一个内部分支，已经开始支持 hive 数据源引入，并且阿里将其贡献出来作为 flink 的一个分支，并且 7 月份 blink 的特性就会 merge 到 flink 1.9 的主分支中。</p>
<span id="more"></span>
<p>在 flink 1.9 release 之前，要想使用 flink 接入 hive 数据源只能使用 blink 分支，但是该分支只是阿里开源出来的一个 MVP 产品，在尝试使用时碰到了一些兼容性的问题，本文记录一下遇到的问题以及解决方案</p>
<h2 id="Hive-1-x-兼容性"><a href="#Hive-1-x-兼容性" class="headerlink" title="Hive 1.x 兼容性"></a>Hive 1.x 兼容性</h2><p>当尝试直接使用编译出来的 blink hive connector 去连接 hive 1.x 时，list table 报了如下错误<br><img src="/2019/Blink-%E9%80%82%E9%85%8D-Hive-1-x/flink-compatible1.png" alt="cannot get table"><br>查看 blink 的依赖发现 blink 默认引入了 hive 2.3.4 的 metastore，而我们访问的是 hive 1.x。hive 从 1.x 到 2.x 大版本升级后应该是 thrift 接口方法发生了大的改变，导致高版本的 hive metastore 无法正常访问到低版本，还好 hive connector 这个模块涉及到的类并不多，因此萌生了手动降依赖的想法，并排查修改一些不兼容的方法。<br>这个跟着 ide compile 的提示来就行了 </p>
<ol>
<li>修改 hive metastore 版本为 1.2.1</li>
<li>修改 RetryingMetaStoreClient#getProxy 方法</li>
<li>去除 1.x 不涉及到的属性定义</li>
</ol>
<p>具体的修改参见 <a href="https://github.com/AkisAya/flink/compare/blink...AkisAya:blink-bumblebee">DIFF TO BLINK</a></p>
<h2 id="Hive-varchar-适配"><a href="#Hive-varchar-适配" class="headerlink" title="Hive varchar 适配"></a>Hive varchar 适配</h2><p>经过上述的修改基本上已经可以连上 hive 1.x 了，但是对于 varchar 类型的字段处理还有问题，如果数据里有有这个类型 hive connector 读数据的时候会报类型转换错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.ClassCastException: org.apache.hadoop.hive.common.type.HiveVarchar cannot be cast to java.lang.String</span><br></pre></td></tr></table></figure>
<p>其原因在与 blink 分支甚至 flink 1.8 为止都不原生支持 varchar 类型，会将 hive varchar 类型转成 string 类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## HiveMetadataUtil</span><br><span class="line">/**</span><br><span class="line">	 * Convert a hive type to Flink internal type.</span><br><span class="line">	 * Note that even though serdeConstants.DATETIME_TYPE_NAME exists, Hive hasn&#x27;t officially support DATETIME type yet.</span><br><span class="line">	 */</span><br><span class="line">	public static InternalType convert(String hiveType) &#123;</span><br><span class="line">		// Note: Any type match changes should be updated in documentation of data type mapping at /dev/table/catalog.md</span><br><span class="line"></span><br><span class="line">		// First, handle types that have parameters such as CHAR(5), DECIMAL(6, 2), etc</span><br><span class="line">		if (isVarcharOrCharType(hiveType)) &#123;</span><br><span class="line">			// For CHAR(p) and VARCHAR(p) types, map them to String for now because Flink doesn&#x27;t yet support them.</span><br><span class="line">			return StringType.INSTANCE;</span><br><span class="line">		&#125; else if (isDecimalType(hiveType)) &#123;</span><br><span class="line">			return DecimalType.of(hiveType);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		switch (hiveType) &#123;</span><br><span class="line">			case serdeConstants.STRING_TYPE_NAME:</span><br><span class="line">				return StringType.INSTANCE;</span><br><span class="line">			case serdeConstants.BOOLEAN_TYPE_NAME:</span><br><span class="line">				return BooleanType.INSTANCE;</span><br><span class="line">			case serdeConstants.TINYINT_TYPE_NAME:</span><br><span class="line">				return ByteType.INSTANCE;</span><br><span class="line">			case serdeConstants.SMALLINT_TYPE_NAME:</span><br><span class="line">				return ShortType.INSTANCE;</span><br><span class="line">			case serdeConstants.INT_TYPE_NAME:</span><br><span class="line">				return IntType.INSTANCE;</span><br><span class="line">			case serdeConstants.BIGINT_TYPE_NAME:</span><br><span class="line">				return LongType.INSTANCE;</span><br><span class="line">			case serdeConstants.FLOAT_TYPE_NAME:</span><br><span class="line">				return FloatType.INSTANCE;</span><br><span class="line">			case serdeConstants.DOUBLE_TYPE_NAME:</span><br><span class="line">				return DoubleType.INSTANCE;</span><br><span class="line">			case serdeConstants.DATE_TYPE_NAME:</span><br><span class="line">				return DateType.DATE;</span><br><span class="line">			case serdeConstants.TIMESTAMP_TYPE_NAME:</span><br><span class="line">				return TimestampType.TIMESTAMP;</span><br><span class="line">			case serdeConstants.BINARY_TYPE_NAME:</span><br><span class="line">				return ByteArrayType.INSTANCE;</span><br><span class="line">			default:</span><br><span class="line">				throw new UnsupportedOperationException(</span><br><span class="line">					String.format(&quot;Flink doesn&#x27;t support Hive&#x27;s type %s yet.&quot;, hiveType));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 varchar 转成了 flink 中的 string 类型<br>更奇葩的是，当要获取一些序列化信息的时候，从 flink 的 string 类型无法还原 varhcar 的序列化信息了，信息在转化过程中失真了，最终导致 varchar 本应该使用 varchar 的序列化类确使用了 string 的序列化类，于是报了类型转化错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Convert Flink&#x27;s internal type to String for hive.</span><br><span class="line"> */</span><br><span class="line">public static String convert(InternalType internalType) &#123;</span><br><span class="line">	if (internalType.equals(BooleanType.INSTANCE)) &#123;</span><br><span class="line">		return serdeConstants.BOOLEAN_TYPE_NAME;</span><br><span class="line">	&#125; else if (internalType.equals(ByteType.INSTANCE)) &#123;</span><br><span class="line">		return serdeConstants.TINYINT_TYPE_NAME;</span><br><span class="line">	&#125; else if (internalType.equals(ShortType.INSTANCE)) &#123;</span><br><span class="line">		return serdeConstants.SMALLINT_TYPE_NAME;</span><br><span class="line">	&#125; else if (internalType.equals(IntType.INSTANCE)) &#123;</span><br><span class="line">		return serdeConstants.INT_TYPE_NAME;</span><br><span class="line">	&#125; else if (internalType.equals(LongType.INSTANCE)) &#123;</span><br><span class="line">		return serdeConstants.BIGINT_TYPE_NAME;</span><br><span class="line">	&#125; else if (internalType.equals(FloatType.INSTANCE)) &#123;</span><br><span class="line">		return serdeConstants.FLOAT_TYPE_NAME;</span><br><span class="line">	&#125; else if (internalType.equals(DoubleType.INSTANCE)) &#123;</span><br><span class="line">		return serdeConstants.DOUBLE_TYPE_NAME;</span><br><span class="line">	&#125; else if (internalType.equals(StringType.INSTANCE)) &#123;</span><br><span class="line">		return serdeConstants.STRING_TYPE_NAME;</span><br><span class="line">	&#125; else if (internalType.equals(CharType.INSTANCE)) &#123;</span><br><span class="line">		return serdeConstants.CHAR_TYPE_NAME + &quot;(1)&quot;;</span><br><span class="line">	&#125; else if (internalType.equals(DateType.DATE)) &#123;</span><br><span class="line">		return serdeConstants.DATE_TYPE_NAME;</span><br><span class="line">	&#125; else if (internalType instanceof TimestampType) &#123;</span><br><span class="line">		return serdeConstants.TIMESTAMP_TYPE_NAME;</span><br><span class="line">	&#125; else if (internalType instanceof DecimalType) &#123;</span><br><span class="line">		return String.format(DECIMAL_TYPE_NAME_FORMAT, ((DecimalType) internalType).precision(), ((DecimalType) internalType).scale());</span><br><span class="line">	&#125; else if (internalType.equals(ByteArrayType.INSTANCE)) &#123;</span><br><span class="line">		return serdeConstants.BINARY_TYPE_NAME;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		throw new UnsupportedOperationException(</span><br><span class="line">			String.format(&quot;Flink&#x27;s hive metadata integration doesn&#x27;t support Flink type %s yet.&quot;,</span><br><span class="line">				internalType.toString()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续 debug 可以发现问题处在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># HiveTableInputFormat，MR 任务读取 HDFS 的数据指定的 input format</span><br><span class="line">    deserializer = (Deserializer) Class.forName(serDeInfoClass).newInstance();</span><br><span class="line">    Configuration conf = new Configuration();</span><br><span class="line">    // 在这里获取序列化器</span><br><span class="line">    SerDeUtils.initializeSerDe(deserializer, conf, properties, null);</span><br><span class="line">    // Get the row structure</span><br><span class="line">    oi = (StructObjectInspector) deserializer.getObjectInspector();</span><br><span class="line">    fieldRefs = oi.getAllStructFieldRefs();</span><br></pre></td></tr></table></figure>
<p>根据 properties 获取序列化器，那么这个 properties 是哪里来的呢？进一步跟踪可以找到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># HiveTableSource</span><br><span class="line">	private Properties createPropertiesFromSdParameters(StorageDescriptor storageDescriptor) &#123;</span><br><span class="line">		SerDeInfo serDeInfo = storageDescriptor.getSerdeInfo();</span><br><span class="line">		Map&lt;String, String&gt; parameters = serDeInfo.getParameters();</span><br><span class="line">		Properties properties = new Properties();</span><br><span class="line">		properties.setProperty(serdeConstants.SERIALIZATION_FORMAT,</span><br><span class="line">							serDeInfo.getParameters().get(serdeConstants.SERIALIZATION_FORMAT));</span><br><span class="line">		List&lt;String&gt; colTypes = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; colNames = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;FieldSchema&gt; cols = storageDescriptor.getCols();</span><br><span class="line">		for (FieldSchema col: cols)&#123;</span><br><span class="line">			colTypes.add(col.getType());</span><br><span class="line">			colNames.add(col.getName());</span><br><span class="line">		&#125;</span><br><span class="line">		properties.setProperty(serdeConstants.LIST_COLUMNS, StringUtils.join(colNames, &quot;,&quot;));</span><br><span class="line">        // 这里设置了 column type，并且用的是 hive type 转化为 flink type 之后的 type，也就是这里信息失真了</span><br><span class="line">		properties.setProperty(serdeConstants.LIST_COLUMN_TYPES, StringUtils.join(colTypes, DEFAULT_LIST_COLUMN_TYPES_SEPARATOR));</span><br><span class="line">		properties.setProperty(serdeConstants.SERIALIZATION_NULL_FORMAT, &quot;NULL&quot;);</span><br><span class="line">		properties.putAll(parameters);</span><br><span class="line">		return properties;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在 HiveTableSource 里设置了列的所有类型，但是这个类型已经是被 flink 转化过的类型，看样子我们找到源头了，所以只要我们设置这个类型为原始的 hive 类型问题就得到了解决。幸运的是，HiveTableSource 在构造的时候本身就提供了一个字段 <code>hiveRowTypeString</code> 表示 hive 里该表的原生类型，我们用它替换掉 properties 里的属性即可，具体的修改参考 <a href="https://github.com/AkisAya/flink/compare/blink...AkisAya:blink-bumblebee">DIFF TO BLINK</a></p>
<p>没想到这么明显的错误居然被阿里的人 push 上来了，甚至于本身就写了注释意识到类型不能用 flink 转化后的类型而应该用 hive 原生类型。这个故事告诉我们永远不要相信 todo 的约束力。MVP 版本不愧为 MVP 版本，根本不应该用在生产上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// TODO: we should get StorageDescriptor from Hive Metastore somehow.</span><br><span class="line">StorageDescriptor sd = createStorageDescriptor(jobConf, rowTypeInfo);</span><br><span class="line">jobConf.setStrings(INPUT_DIR, sd.getLocation());</span><br><span class="line">Properties properties = createPropertiesFromSdParameters(sd);</span><br></pre></td></tr></table></figure>

<h2 id="limit-失效问题"><a href="#limit-失效问题" class="headerlink" title="limit 失效问题"></a>limit 失效问题</h2><p>blink 的 api 相比 flink 还是有点出入的，在使用上有点要注意的<br>对于 hive 引入来说，需要设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">env.setJobType(JobType.BATCH);</span><br></pre></td></tr></table></figure>
<p>不然 sql 里的 limit 会导致任务挂住</p>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>即便做了这些修改，blink 读取 hive 数据源的时候，仍无法正确处理分区字段类型为非 string 类型的数据，在写 flink sql 的时候，无法将分区字段 select 出来作为一个新的列。这是因为 blink 在处理分区字段时候把所有的分区字段值都读成了 string（因为直接从文件夹路径读的数据值），但是元数据信息里保存的类型不是 string 的时候就会进行类型转换，而这个类型转换基本都会失败。但是如果不把分区字段 select 出来作为一个新的列，而是放在 where 条件里倒是没有关系</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>flink 流处理方面确实很优秀，但是在数据源的兼容性上，离线的计算方面还是需要追赶 spark。flinlk 1.9 将在 7 月份发布，blink 特性会 merge 到主分支，提供 hive connector 和对低版本 hive 的兼容性，并且会重构类型系统原生支持 varchar 等类型。让我们静静期待吧。</p>
<p>最后，千万不要在生产上使用未经验证的解决方案</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://blink.flink-china.org/">Blink 参考手册</a><br><a href="https://zh.ververica.com/">Flink 社区</a></p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>flink</tag>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Goroutine 泄露案例分享</title>
    <url>/2022/Goroutine-%E6%B3%84%E9%9C%B2/</url>
    <content><![CDATA[<p>golang 可以很方便的通过 go 关键字开一个协程，但是不正确的使用，也容易造成协程泄漏，下面分享我碰到的案例</p>
<span id="more"></span>
<h1 id="泄漏案例"><a href="#泄漏案例" class="headerlink" title="泄漏案例"></a>泄漏案例</h1><h2 id="1-channel-容量不当，导致发送但不接收"><a href="#1-channel-容量不当，导致发送但不接收" class="headerlink" title="1 channel 容量不当，导致发送但不接收"></a>1 channel 容量不当，导致发送但不接收</h2><p>通常我们在主线程有一个耗时的执行逻辑，希望控制超时时间，就会对耗时逻辑开一个 goroutine，同时主线程等待 timeout</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">timeout := time.After(<span class="number">200</span> * time.Millisecond)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">    fmt.Println(<span class="string">&quot;run fast&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">    fmt.Println(<span class="string">&quot;run timeout&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>乍一看，这个逻辑好像没有问题，但是如果一旦超时发生了我们的 goroutine 却会被阻塞在 <code>ch &lt;- 1</code>这一行，因为超时一旦发生，select 逻辑执行完毕，最终 ch 就失去了接收者，那么发送方就会发生阻塞，导致 goroutine 无法运行结束。这里关键就在于声明 ch 的时候，没有给定容量。所以最简单的解决方法就是生命一个容量为 1 的 ch。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="2-忘记关-channel-导致泄漏"><a href="#2-忘记关-channel-导致泄漏" class="headerlink" title="2 忘记关 channel 导致泄漏"></a>2 忘记关 channel 导致泄漏</h2><p>大部分情况下，channel 不需要我们手动关闭，使用完之后会被垃圾回收掉。不过如果我们在做一个资源清理，重置之类的逻辑的时候就需要注意 channel 的使用是否被正确关闭了。<br>这里举一个 hystrix-go 开源库的一个忘记关闭 channel 导致泄漏的 bug，<a href="https://github.com/afex/hystrix-go/pull/64">Fix goroutines leakage when flushing hystrix configuration</a>, hystrix-go 有个 flush 操作，清除限流的配置，但是原来在配置的时候，开了一个 goroutine，对请求采样监控，里面有一段逻辑是</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// m.Updates 是一个 channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *poolMetrics)</span></span> Monitor() &#123;</span><br><span class="line">	<span class="keyword">for</span> u := <span class="keyword">range</span> m.Updates &#123;</span><br><span class="line">		m.Mutex.RLock()</span><br><span class="line"></span><br><span class="line">		m.Executed.Increment(<span class="number">1</span>)</span><br><span class="line">		m.MaxActiveRequests.UpdateMax(<span class="type">float64</span>(u.activeCount))</span><br><span class="line"></span><br><span class="line">		m.Mutex.RUnlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是 channel 有接收者(此处为 m.Updates)，但是由于 flush 之后，channel 没有 close，导致这个 monitor 的逻辑不会退出。最简单的修复方式自然是 flush 时加上 close channel 的方法，具体可以参考上文中的 pr。不过 hystrix-go 这个项目基本没在维护了，这个 pr 是没有被 merge。</p>
<h2 id="3-timer-阻塞"><a href="#3-timer-阻塞" class="headerlink" title="3 timer 阻塞"></a>3 timer 阻塞</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *MysqlLocker)</span></span> keepAlive() &#123;</span><br><span class="line">	tick := <span class="number">10</span></span><br><span class="line">	timer := time.NewTimer(time.Duration(tick) * time.Second)</span><br><span class="line">	<span class="keyword">defer</span> timer.Stop()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">			<span class="comment">// do something</span></span><br><span class="line">            doSomething()</span><br><span class="line">			timer.Reset(time.Duration(tick) * time.Second)</span><br><span class="line">		<span class="keyword">case</span> &lt;-l.donec:</span><br><span class="line">			<span class="comment">// This &quot;if&quot; block is important.</span></span><br><span class="line">			<span class="comment">// the if code block is used to discard/drain a possible timer notification</span></span><br><span class="line">			<span class="keyword">if</span> !timer.Stop() &#123;</span><br><span class="line">				&lt;-timer.C</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们有个 mysql 锁，要定期给锁续期，用到了 timer 做定时任务，如果锁释放了，<code>l.donec</code>这个 channel 会受到消息，最后退出续期的逻辑<br>这段代码里，很容易忽略掉<code>if !timer.Stop() &#123; &lt;-timer.C &#125;</code>这段 if 判断。如果没有这个判断去消费可能存在 channel 中的消息，那发送方就会阻塞，最终造成 timer 泄露。如果我们查看 timer 的 stop 方法，就会发现这个 if 判断也是推荐的做法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// To ensure the channel is empty after a call to Stop, check the</span></span><br><span class="line"><span class="comment">// return value and drain the channel.</span></span><br><span class="line"><span class="comment">// For example, assuming the program has not received from t.C already:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 	if !t.Stop() &#123;</span></span><br><span class="line"><span class="comment">// 		&lt;-t.C</span></span><br><span class="line"><span class="comment">// 	&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="如何发现并排查-goroutine-泄漏"><a href="#如何发现并排查-goroutine-泄漏" class="headerlink" title="如何发现并排查 goroutine 泄漏"></a>如何发现并排查 goroutine 泄漏</h1><h2 id="1-监控"><a href="#1-监控" class="headerlink" title="1 监控"></a>1 监控</h2><p>首先我们可以对应用的 goroutine 进行监控，prometheus 本身就有开箱即用的监控指标，引入 prometheus sdk，在 grafana 这样子的可视化监控 dashboard 上配置好图标就行，发现不正常的增长就需要立刻排查。</p>
<h2 id="2-pprof-查看-goroutine"><a href="#2-pprof-查看-goroutine" class="headerlink" title="2 pprof 查看 goroutine"></a>2 pprof 查看 goroutine</h2><p>go 内置的 pprof 工具可以很方便的查看 goroutine 的数量分布</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>别人总结的<br><a href="https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html">Goroutine Leaks - The Forgotten Sender</a><br><a href="https://juejin.cn/post/6844903891935461383">如何防止 goroutine 泄露 - 掘金</a></p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop 单机配置</title>
    <url>/2017/Hadoop-%E5%8D%95%E6%9C%BA%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="1-前置安装程序"><a href="#1-前置安装程序" class="headerlink" title="1 前置安装程序"></a>1 前置安装程序</h2><h3 id="1-1-安装-JDK"><a href="#1-1-安装-JDK" class="headerlink" title="1.1 安装 JDK"></a>1.1 安装 JDK</h3><p>参考 <a href="https://www.cnblogs.com/a2211009/p/4265225.html">安装 JDK 的两种方式</a></p>
<h3 id="1-2-安装-SSH"><a href="#1-2-安装-SSH" class="headerlink" title="1.2 安装 SSH"></a>1.2 安装 SSH</h3><p>在 Ubuntu 环境下，首先安装 SSH</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install ssh</span><br></pre></td></tr></table></figure>
<p>然后配置免密码登录本机节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -P &#x27;&#x27; -f ~/.ssh/id_rsa</span><br><span class="line">$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line">$ chmod 0600 ~/.ssh/authorized_keyss</span><br><span class="line">$ ssh localhost</span><br></pre></td></tr></table></figure>

<h2 id="2-安装配置-Hadoop"><a href="#2-安装配置-Hadoop" class="headerlink" title="2 安装配置 Hadoop"></a>2 安装配置 Hadoop</h2><p>在官网下载 Hadoop 安装包并解压，本文以 Hadoop-2.8.2 为例，Hadoop 从 1.x 到 2.x 后解压后的包结构有所变化，1.x 中 <code>conf</code> 文件夹在 2.x 中已不在，在 2.x 中配置文件存放在了 <code>etc/hadoop</code> 中。</p>
<p>为了后续方便调用 Hadoop 的命令，添加相应的环境变量，在 <code>~/.bashrc</code> 中最后添加上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export HADOOP_HOME=~/program/hadoop2   # hadoop 的解压后存放路径</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br></pre></td></tr></table></figure>

<p>在单节点的 Hadoop 配置中包含默认<strong>单机模式(Standalone Operation)<strong>和</strong>伪分布式模式(Pseudo-Distributed Operation)</strong></p>
<h3 id="2-1-单机模式-Standalone-Operation"><a href="#2-1-单机模式-Standalone-Operation" class="headerlink" title="2.1 单机模式 - Standalone Operation"></a>2.1 单机模式 - Standalone Operation</h3><p>hadoop 压缩包解压后无需任何配置，该方式可以用来调试<br>hadoop 安装包中自带了 example 可以用来测试，在 2.x 版本中该示例存放在 <code>hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.x.x.jar</code><br>在单机模式下，没有使用到 hadoop 的 hdfs 系统，输入数据和输出数据都是存放在本机上，可以直接用本机上的数据进行测试。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir input</span><br><span class="line">$ echo &quot;hello world hello python hello java bye java bye bye&quot; &gt; file</span><br><span class="line">$ mv file input </span><br><span class="line">$ hadoop jar  program/hadoop2/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.8.2.jar wordcount input output</span><br></pre></td></tr></table></figure>
<p>output 是输出文件夹，不要提前自行该创建该文件夹。该文件夹中包含了输出结果和成功信息，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls output</span><br><span class="line">part-r-00000  _SUCCESS</span><br><span class="line">akis@ubuntu:~$ cat output/part-r-00000 </span><br><span class="line">bye    3</span><br><span class="line">hello    3</span><br><span class="line">java    2</span><br><span class="line">python    1</span><br><span class="line">world    1</span><br></pre></td></tr></table></figure>

<h3 id="2-2-伪分布式模式-Pseudo-Distributed-Operation"><a href="#2-2-伪分布式模式-Pseudo-Distributed-Operation" class="headerlink" title="2.2 伪分布式模式 - Pseudo-Distributed Operation"></a>2.2 伪分布式模式 - Pseudo-Distributed Operation</h3><p>伪分布式模式用到了 hadoop 的 hdfs，输入输出文件由 hdfs 管理，相比单机模式更接近生产环境。伪分布式模式可以看做只有一个节点的集群，配置过程需要修改 <code>etc/hadoop</code> 中的一些文件。</p>
<p>在 <code>hadoop-evn.sh</code> 中配置 JAVA_HOME:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># The java implementation to use.</span><br><span class="line">export JAVA_HOME=/opt/jdk8  # 此处需要使用绝对路径</span><br></pre></td></tr></table></figure>

<p>修改 <code>core-site.xml</code>，此处配置的是 HDFS 的地址及端口号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>修改 <code>hdfs-site.xml</code>，此处配置备份数量，默认是 3，修改为 1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>此时已经可以运行 Hadoop 了.<br>首先初始化系统，然后启动 NameNode 和 DataNode:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hdfs namenode -format</span><br><span class="line">$ start-dfs.sh</span><br></pre></td></tr></table></figure>

<p>然后可以运行 <code>jps</code> 查看运行的进程，有如下 <code>NameNode</code>, <code>DataNode</code>, <code>SecondaryNameNode</code> 则运行成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">akis@ubuntu:~$ jps</span><br><span class="line">12241 NameNode</span><br><span class="line">14070 Jps</span><br><span class="line">12589 SecondaryNameNode</span><br><span class="line">12366 DataNode</span><br></pre></td></tr></table></figure>

<p>此时输入输出的文件都由 hdfs 来管理，使用 <code>FileSystem Shell</code> 中的 <code>put</code> 可以将本地文件上传到 hdfs 中，然后可运行示例程序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hadoop fs -mkidr -p /wordcount/input    # 在 hdfs 中创建文件夹</span><br><span class="line">$ hadoop fs -put input/* /wordcount/input   # 将本地的 input 文件夹内容拷贝至 hdfs 中</span><br><span class="line">$ hadoop jar  program/hadoop2/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.8.2.jar wordcount /wordcount/input /wordcount/output</span><br><span class="line">$ hadoop fs -cat /wordcount/output/part-r-00000 # 运行成功后 output 文件夹中文件同上文的单机模式时一致，使用 cat 查看如下</span><br><span class="line">bye    3</span><br><span class="line">hello    3</span><br><span class="line">java    2</span><br><span class="line">python    1</span><br><span class="line">world    1</span><br></pre></td></tr></table></figure>

<p>如果要使程序运行在 yarn 上，需要再配置。<br>修改 <code>mapred-site.xml</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>同时修改 <code>yarn-site.xml</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>启动 yarn：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ start-yarn.sh</span><br></pre></td></tr></table></figure>

<p>如果要停止服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$stop-yarn.sh</span><br><span class="line">$stop-dfs.sh</span><br></pre></td></tr></table></figure>

<p>在单机模式、伪分布模式和基于 yarn 的伪分布模式三种模式中，用小数据量测试时运行速度依次变慢，三种模式耗费的硬件资源依次增多。在笔者的测试中，在虚拟机中配置好后，yarn 模式运行很慢。<strong>如果出现了再 yarn 模式下运行出错的情况，可以尝试增大虚拟机内存，笔者虚拟机内存在 2G 时，运行自带的 wordcount 示例也会出现 connection refused 和 namenode 断掉的情况，将内存增加至 4G 后问题解决了!</strong></p>
<h2 id="3-可能出现的问题"><a href="#3-可能出现的问题" class="headerlink" title="3 可能出现的问题"></a>3 可能出现的问题</h2><p>如果遇到 namenode 无法启动的情况，可能是默认的缓存文件夹的问题，则此时在 <code>core-site.xml</code> 更改缓存的位置后重新格式化即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/home/akis/hadoop_tmp&lt;/value&gt;  &lt;!-- 指定本机上的一个目录, 默认目录在本机的 /tmp 下--&gt;</span><br><span class="line">    &lt;description&gt;A base for other temporary directories.&lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<p>如果遇到端口占用无法启动则杀掉该端口或者换端口即可。如果控制台没有输出错误信息，可以查看 hadoop 安装路径下的 log 文件夹中查看对应的 log 信息。</p>
<h2 id="4-Reference"><a href="#4-Reference" class="headerlink" title="4 Reference"></a>4 Reference</h2><ul>
<li><a href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/SingleCluster.html">Setting up a Single Node Cluster</a></li>
<li><a href="http://blog.csdn.net/scgaliguodong123_/article/details/44498173">解决Hadoop namenode无法启动以及修改hdfs的存放位置</a></li>
<li><a href="https://segmentfault.com/a/1190000006838239">hadoop启动遇到的各种问题</a></li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven打包项目二三事</title>
    <url>/2018/Maven%E6%89%93%E5%8C%85%E9%A1%B9%E7%9B%AE%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
    <content><![CDATA[<h2 id="使用-Maven-打包项目"><a href="#使用-Maven-打包项目" class="headerlink" title="使用 Maven 打包项目"></a>使用 Maven 打包项目</h2><p>我们在 Idea 构建 Maven 工程时，在 Idea 的侧边栏可以调出 Maven 相关的操作选项，可以很容易的来执行生命周期，clean 可以清理编译出来的文件，compile 对文件进行编译，package 将项目进行打包，install 将打包完成的包发布到本地的 Maven 仓库。如果我们没有为各个生命周期配置插件，Maven 将使用默认的插件完成这些生命周期。例如，Maven 默认使用 maven-jar-plugin 对项目进行打包，打包生成的包只能作为一个依赖包使用，不能作为一个可执行包，要作为一个可执行包，需要配置 <code>Main-Class</code></p>
<span id="more"></span>

<h2 id="Maven-项目读取本地-Jar-包"><a href="#Maven-项目读取本地-Jar-包" class="headerlink" title="Maven 项目读取本地 Jar 包"></a>Maven 项目读取本地 Jar 包</h2><p>要在本地项目中引入本地的 Jar 包，网上很多，这里就说说通过 Scope 引入本地包的方法。<br>在 pom.xml 中添加下面的 dependency</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;basedir&#125;/lib/commons-lang3-3.8.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在项目中则需要在根目录下新建 lib 文件夹，然后将 jar 包置入</p>
<p>其实如果不想后续打包可能造成的麻烦，最好是 install 到本地仓库然后引入</p>
<h2 id="使用-maven-jar-plugin-打包可执行文件"><a href="#使用-maven-jar-plugin-打包可执行文件" class="headerlink" title="使用 maven-jar-plugin 打包可执行文件"></a>使用 maven-jar-plugin 打包可执行文件</h2><p>使用 maven-jar-plugin 打包出来的可执行 jar 是不包含依赖的，所以我们需要将依赖也打包出来，需要使用 dependency-plguin 的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">classpathPrefix</span>&gt;</span>lib/<span class="tag">&lt;/<span class="name">classpathPrefix</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--可以把依赖本地系统的Jar包加入Manifest文件中--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Class-Path</span>&gt;</span>lib/commons-lang3-3.8.jar<span class="tag">&lt;/<span class="name">Class-Path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/lib<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">overWriteReleases</span>&gt;</span>false<span class="tag">&lt;/<span class="name">overWriteReleases</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">overWriteSnapshots</span>&gt;</span>false<span class="tag">&lt;/<span class="name">overWriteSnapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">overWriteIfNewer</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overWriteIfNewer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>	</span><br></pre></td></tr></table></figure>
<p>jar-plugin 的 <classpathPrefix> 指定了 classpath 的位置，本案例中即读取可执行包同级目录下的 lib 目录，可执行 jar 的 Manifest 文件如下。dependency-plugin 则将 maven 中的依赖包打包到 <outputDirectory> 指定目录下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Built-By: akis</span><br><span class="line">Class-Path: lib/guava-26.0-jre.jar lib/jsr305-3.0.2.jar lib/checker-qu</span><br><span class="line"> al-2.5.2.jar lib/error_prone_annotations-2.1.3.jar lib/j2objc-annotat</span><br><span class="line"> ions-1.1.jar lib/animal-sniffer-annotations-1.14.jar lib/commons-lang</span><br><span class="line"> 3-3.8.jar</span><br><span class="line">Created-By: Apache Maven 3.3.9</span><br><span class="line">Build-Jdk: 1.8.0_172</span><br><span class="line">Main-Class: Test</span><br></pre></td></tr></table></figure>

<h3 id="将依赖包打包到可执行包中"><a href="#将依赖包打包到可执行包中" class="headerlink" title="将依赖包打包到可执行包中"></a>将依赖包打包到可执行包中</h3><p>要将依赖包中打包到可执行包中，有很多插件能做到，这里介绍一下 shade-plugin</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Main-Class</span>&gt;</span>$&#123;app.main.class&#125;<span class="tag">&lt;/<span class="name">Main-Class</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">X-Compile-Source-JDK</span>&gt;</span>$&#123;maven.compiler.source&#125;<span class="tag">&lt;/<span class="name">X-Compile-Source-JDK</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">X-Compile-Target-JDK</span>&gt;</span>$&#123;maven.compiler.target&#125;<span class="tag">&lt;/<span class="name">X-Compile-Target-JDK</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>	</span><br></pre></td></tr></table></figure>
<p>该插件能将依赖包导入可行性 jar 包，但是不会引入上文提到的本地引入的依赖包，如果想导入本地依赖的包到可执行 jar，可以使用 <a href="https://blog.csdn.net/gaopu12345/article/details/78596830">addjars-maven-plugin</a>，有兴趣的读者可以试试</p>
<p>当然使用 java -cp 命令而不是 java -jar 命令来执行主类的话，可以暂时解决外置依赖没打包进依赖包的问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// java -cp xx.jar:lib/xx.jar packageName.MainClassName</span><br><span class="line">java -cp testpackage-1.0-SNAPSHOT.jar:lib/commons-lang3-3.8.jar Test</span><br></pre></td></tr></table></figure>
<p>最近发现<code>ManifestResourceTransformer</code> 除了可以指定 <code>MainClass</code>, 其实还可以指定 Manifest 文件里任意的属性，类的名字也隐含了这一点，所以如果利用 <code>shade-plugin</code> 的话，可以指定读取外置的依赖，只需要在 <code>manifestEntries</code> 中增加 <code>Class-Path</code> 属性，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Main-Class</span>&gt;</span>$&#123;app.main.class&#125;<span class="tag">&lt;/<span class="name">Main-Class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">X-Compile-Source-JDK</span>&gt;</span>$&#123;maven.compiler.source&#125;<span class="tag">&lt;/<span class="name">X-Compile-Source-JDK</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">X-Compile-Target-JDK</span>&gt;</span>$&#123;maven.compiler.target&#125;<span class="tag">&lt;/<span class="name">X-Compile-Target-JDK</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Class-Path</span>&gt;</span>lib/$&#123;planet-graph-lib&#125;<span class="tag">&lt;/<span class="name">Class-Path</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>打包后，就可以用 java -jar 来运行了</p>
<h2 id="springboot-项目打包"><a href="#springboot-项目打包" class="headerlink" title="springboot 项目打包"></a>springboot 项目打包</h2><p>springboot 项目默认使用了 spring-boot-maven-plugin，默认会打包一个嵌入了 tomcat 的可执行 jar 包，最近做的一个项目里就需要引入外置的 jar 包，并且不将其打包到 springboot 的可执行 jar 里，所以可以用上文提到的引入方法。这样如果我们的外置 jar 更新了，只需要替换掉外置的这个 jar，已经打包的应用则不需要更改。<br>那么需要解决的问题是在运行 springboot 打包出来的可执行 jar 的时候能够读到外置的这个 jar 依赖。</p>
<p>首先给出解决方案，配置 spring-boot-maven-plugin，将其 layout 改为 ZIP</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span>&gt;</span>ZIP<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executable</span>&gt;</span>true<span class="tag">&lt;/<span class="name">executable</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在运行的时候加上 -Dloader.path 这个参数，lib 是 springboot 应用同级目录下的外置依赖目录，我们的外置依赖就放在这个 lib 中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Dloader.path=lib ph_pg-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod</span><br></pre></td></tr></table></figure>
<p>原因是 springboot 应用启动时时从 org.springframework.boot.loader.JarLauncher 开始启动的，该启动器会忽略外置的 classpath 下的包，因此需要替换成 PropertiesLauncher，配置 layout 为 ZIP 后，springboot 就从 PropertiesLauncher 开始启动，并且使用 loader.path 配置外置的 classpath</p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://stackoverflow.com/questions/40994851/spring-boot-executable-jar-layout-changes-break-classpath">StackOverflow</a><br><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#executable-jar-launching">Springboot Reference</a><br><a href="https://www.jianshu.com/p/a2cf2336a48c">SpringBoot加载外部依赖</a><br><a href="https://blog.csdn.net/timedifier2/article/details/53925825">Springboot的“fat jar” 变成 “thin jar”</a>, 这篇很值得看下</p>
<h2 id="Maven-打包时排除掉某个文件"><a href="#Maven-打包时排除掉某个文件" class="headerlink" title="Maven 打包时排除掉某个文件"></a>Maven 打包时排除掉某个文件</h2><p>项目里 License 模块，LicenseGenerator 也在模块里，但是打包的时候我们就不能把这个文件打包到依赖包里了，解决方法是，打包时，让这个文件不参与编译就行了，如下，需要注意的是其他的 java 类里也不要 import 这个 LicenseGenerator，不然还是会被编译。我们及时清除不需要的 import 是个好习惯</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>path/to/license/LicenseGenerator.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>闲来无事，记录下碰到的 Maven 打包的问题吧</p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>Ngnix 流量拷贝</title>
    <url>/2019/Ngnix-%E6%B5%81%E9%87%8F%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>在需要真实的流量做旁路测试的时候，我们就可以使用 nginx 来做流量的拷贝</p>
<span id="more"></span>
<h2 id="1-Nginx-Mirror-模块"><a href="#1-Nginx-Mirror-模块" class="headerlink" title="1 Nginx Mirror 模块"></a>1 Nginx Mirror 模块</h2><p>nginx 自1.13.4 版本开始，自带一个 <a href="http://nginx.org/en/docs/http/ngx_http_mirror_module.html">ngx_http_mirror_module</a>，使用起来非常简单，只要在需要 mirror 的 location 处添加 mirror 关键字就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    mirror /mirror;</span><br><span class="line">    proxy_pass http://backend;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location = /mirror &#123;</span><br><span class="line">    internal;</span><br><span class="line">    proxy_pass http://test_backend$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个简单的 nginx 配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line"> </span><br><span class="line">    upstream webserver1 &#123;</span><br><span class="line">        server  127.0.0.1:8881;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    upstream webserver2 &#123;</span><br><span class="line">        server  127.0.0.1:8882;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8080;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"> </span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    location /test &#123;</span><br><span class="line">            mirror /mirror;</span><br><span class="line">            proxy_pass http://webserver1/index;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        location /mirror &#123;</span><br><span class="line">            internal;</span><br><span class="line">            proxy_pass http://webserver2/index;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-lua-脚本分发请求"><a href="#2-lua-脚本分发请求" class="headerlink" title="2 lua 脚本分发请求"></a>2 lua 脚本分发请求</h2><p>但是 nginx 版本过低时，该如何做呢？<br>我们可以使用集成来 lua 的 <a href="https://openresty.org/cn/">OpenResty</a>，使用 lua 脚本处理 web 请求完成流量的拷贝<br>我们直接看例子：<br>nginx.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user root;</span><br><span class="line">worker_processes  1;</span><br><span class="line">error_log logs/error.log;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line"> </span><br><span class="line">    upstream product &#123;</span><br><span class="line">            server  127.0.0.1:8881;</span><br><span class="line">    &#125;</span><br><span class="line">    upstream test &#123;</span><br><span class="line">            server  127.0.0.1:8882;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">            listen      8080;</span><br><span class="line">            server_name 172.27.133.28;</span><br><span class="line">            #lua_code_cache off;</span><br><span class="line"> </span><br><span class="line">            # 外部应用的请求地址，通过 lua 脚本分发到新的 product 和 test 地址</span><br><span class="line">            location /predict/fake &#123;</span><br><span class="line">                    client_body_buffer_size 2m;</span><br><span class="line">                    set $switch    &quot;on&quot;;              #开启或关闭copy功能</span><br><span class="line">                    content_by_lua_file /tmp/copy_req.lua;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            # lua 脚本分发到 product，并且对 url 重写后，反向代理到 product 的 server</span><br><span class="line">            location ~* ^/product &#123;</span><br><span class="line">                    log_subrequest on;</span><br><span class="line">                    rewrite ^/product(.*)$ /predict break;</span><br><span class="line">                    proxy_set_header Host $host;</span><br><span class="line">                    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">                    proxy_pass http://product;</span><br><span class="line">                    access_log logs/product-upstream.log;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            # lua 脚本分发到 test，并且对 url 重写后，反向代理到 test 的 server</span><br><span class="line">            location ~* ^/test &#123;</span><br><span class="line">                    log_subrequest on;</span><br><span class="line">                    rewrite ^/test(.*)$ /predict break;</span><br><span class="line">                    proxy_set_header Host $host;</span><br><span class="line">                    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">                    proxy_pass http://test;</span><br><span class="line">                    access_log logs/test-upstream.log;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>copy_req.lua</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local res1, res2, action</span><br><span class="line">action = ngx.var.request_method</span><br><span class="line">if action == &quot;POST&quot; then</span><br><span class="line">        arry = &#123;method = ngx.HTTP_POST, body = ngx.req.read_body()&#125;</span><br><span class="line">else</span><br><span class="line">        arry = &#123;method = ngx.HTTP_GET&#125;</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">if ngx.var.switch == &quot;on&quot; then</span><br><span class="line">        res1, res2 = ngx.location.capture_multi &#123;    -- 分发请求的核心函数</span><br><span class="line">                &#123; &quot;/product&quot; .. ngx.var.request_uri , arry&#125;,</span><br><span class="line">                &#123; &quot;/test&quot; .. ngx.var.request_uri , arry&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">else</span><br><span class="line">        res1, res2 = ngx.location.capture_multi &#123;</span><br><span class="line">                &#123; &quot;/product&quot; .. ngx.var.request_uri , arry&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">if res1.status == ngx.HTTP_OK then</span><br><span class="line">        local header_list = &#123;&quot;Content-Length&quot;, &quot;Content-Type&quot;, &quot;Content-Encoding&quot;, &quot;Accept-Ranges&quot;&#125;</span><br><span class="line">        for _, i in ipairs(header_list) do</span><br><span class="line">                if res1.header[i] then</span><br><span class="line">                        ngx.header[i] = res1.header[i]</span><br><span class="line">                end</span><br><span class="line">        end</span><br><span class="line">        ngx.say(res1.body)</span><br><span class="line">else</span><br><span class="line">        ngx.status = ngx.HTTP_NOT_FOUND</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>我们来捋一捋这个流程：<br>背景：首先我们向外部注册的地址的是 &#x2F;predict&#x2F;fake，我们实际 web server 的地址是 &#x2F;predict，然后一个生产的 upstream （product）一个测试用的 upstream（test），ok，这时候一个 &#x2F;predict&#x2F;fake 请求过来了发生了什么呢</p>
<ol>
<li>首先 &#x2F;predict&#x2F;fake 匹配到了 location，然后经过 lua 脚本分发请求，产生了两个子请求 &#x2F;product&#x2F;predict&#x2F;fake 和 &#x2F;test&#x2F;predict&#x2F;fake</li>
<li>&#x2F;product&#x2F;predict&#x2F;fake 匹配到新的 location，并且对这个 url 进行了 rewrite，变成了真实的后端请求地址 &#x2F;predict，并且反向代理到 product 这个 upstream 下的 server，同理对  &#x2F;test&#x2F;predict&#x2F;fake 也是一样的</li>
<li>两个子请求都有返回，但是在 lua 脚本中，只有 product 对应的请求被最终返回给了前端</li>
</ol>
<p>需要注意的点：<br>反向代理时 rewrite 后的 url 会覆盖 proxy_pass 的 url</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://segmentfault.com/a/1190000018933857">nginx 之 proxy_pass 接口转发的规则</a></p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal 源码阅读(JDK8)</title>
    <url>/2018/ThreadLocal%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<blockquote>
<p>ThreadLocal 为线程提供了线程本地变量，不同于其他的变量，线程本地变量是通过 get() 和 set() 方法。ThreadLocal 通常是一个私有静态域，与Thread中的某个状态相关联（如：UserID 或者 TransactionId）</p>
</blockquote>
<p>ThreadLocal 能够用来实现多线程中数据的隔离，避免不必要的并发控制的麻烦。</p>
<span id="more"></span>

<h2 id="ThreadLocal-的基本使用"><a href="#ThreadLocal-的基本使用" class="headerlink" title="ThreadLocal 的基本使用"></a>ThreadLocal 的基本使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ThreadLocalTest &#123;</span><br><span class="line">    public static ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Integer initialValue() &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(threadLocal.get());</span><br><span class="line">        threadLocal.set(5);</span><br><span class="line">        System.out.println(threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ThreadLocal 是泛型的。除了 ThreadLocal 的 get() 和 set() 和 remove() 方法外，在实例化一个 ThreadLocal 的时候，还可以选择覆盖 initialValue() 方法提供一个初值。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>那么 ThreadLocal 是怎么实现的呢?<br>每个 Thread 都含有一个采用线性探测的Hash Map，这个 Map 不是 JDK 中提供的 HashMap，而是定义在 ThreadLocal 中的一个静态内部类 ThreadLocalMap。<br>来看一看 ThreadLocal 中 get() 和 set() 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">private T setInitialValue() &#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void remove() &#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    if (m != null)</span><br><span class="line">        m.remove(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在 get() 方法中先获取当前线程，然后得到当前线程的 Map 对象，以 ThreadLocal 这个对象本身为 key 取出值。如果得到的 map 为空，说明是第一次访问这个方法并且在之前没有执行过 set() 方法，那么就返回类在实例化时覆盖的 initialValue() 方法的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    return t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getMap() 方法返回了 Thread 的 threadLocals 变量，说明这个 Map 对象是定义在 Thread 中的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Thread.java</span><br><span class="line">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="line"> * by the ThreadLocal class. */</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</span><br></pre></td></tr></table></figure>
<p>在上述的 set() 和 setInitialValue() 方法中可以看到如果 Map 还没有创建则创建 Map 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">    t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，完成了 Thread 的 threadLocals 的实例化。</p>
<h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>ThreadLocalMap 是定义在 ThreadLocal 中的静态内部类，它是一种 Hash 的 Map，以 ThreadLocal 为 Key。但是 并不是用的继承自 Object 对象的 hashcode() 方法产生 hash 值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final int threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The next hash code to be given out. Updated atomically. Starts at</span><br><span class="line"> * zero.</span><br><span class="line"> */</span><br><span class="line">private static AtomicInteger nextHashCode =</span><br><span class="line">    new AtomicInteger();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The difference between successively generated hash codes - turns</span><br><span class="line"> * implicit sequential thread-local IDs into near-optimally spread</span><br><span class="line"> * multiplicative hash values for power-of-two-sized tables.</span><br><span class="line"> */</span><br><span class="line">private static final int HASH_INCREMENT = 0x61c88647;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Returns the next hash code.</span><br><span class="line"> */</span><br><span class="line">private static int nextHashCode() &#123;</span><br><span class="line">    return nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个 ThreadLocal 都有一个 threadLocalHashCode 与其绑定，并且通过一个静态的原子类，保证了每个类的 threadLocalHashCode 都不相同。此外还加上了一个静态常量，按注释看是<del>将这个 hashcode 变成一个二次方表中的近最优扩展的乘法哈希值</del>（turns implicit sequential thread-local IDs into near-optimally spread multiplicative hash values for power-of-two-sized tables，大误，猜测是为了优化后续的hash冲突的）。</p>
<p>下面来看一看 ThreadLocalMap</p>
<blockquote>
<p>ThreadLocalMap is a customized hash map suitable only for maintaining thread local values. No operations are exported outside of the ThreadLocal class. The class is package private to allow declaration of fields in class Thread.  To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys. However, since reference queues are not used, stale entries are guaranteed to be removed only when the table starts running out of space.</p>
</blockquote>
<p>ThreadLocalMap 是一个静态内部类，只是为了给 ThreadLocal 提供辅助而不对外提供接口，同时每一 Entry 的键使用了弱引用，会导致键的垃圾回收。这种键被垃圾回收的 Entry 就是一个旧的条目，虽然键为空，但是 Value 仍可能指向一个对象。旧条目会在 table 容量不足的时候被清理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    /** The value associated with this ThreadLocal. */</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        super(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上为 Entry 的定义，ThreadLocal 对象作为一个 Key 被包装成了一个虚引用。</p>
<p>前文提到了 ThreadLocalMap 是采用了线性探测的 Hash Map，所以内部是维护了一个数组用来存放键值对。初始值为 16, 容量必须为 2 的倍数，因为 2^n - 1 的二进制表示全是 1 (15 &#x3D; 0b1111)，再得到 Entry 在数组中的索引的时候，保证刚好是 &lt;&#x3D; INITIAL_CAPACITY 的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The initial capacity -- MUST be a power of two.</span><br><span class="line"> */</span><br><span class="line">private static final int INITIAL_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The table, resized as necessary.</span><br><span class="line"> * table.length MUST always be a power of two.</span><br><span class="line"> */</span><br><span class="line">private Entry[] table;</span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = new Entry[INITIAL_CAPACITY];</span><br><span class="line">    int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="line">    table[i] = new Entry(firstKey, firstValue);</span><br><span class="line">    size = 1;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细看下 ThreadLocalMap 的 get 和 set 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    if (e != null &amp;&amp; e.get() == key)</span><br><span class="line">        return e;</span><br><span class="line">    else</span><br><span class="line">        return getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始假定可以直接命中，直接命中的话就直接返回，没有命中的话再委托给 getEntryAfterMiss， 这个方法会进行线性探测。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line"></span><br><span class="line">    while (e != null) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        if (k == key)</span><br><span class="line">            return e;</span><br><span class="line">        if (k == null)</span><br><span class="line">             (i); // 删除陈旧的条目，并重新组织数据</span><br><span class="line">        else</span><br><span class="line">            i = nextIndex(i, len); // 探测</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line"></span><br><span class="line">    // We don&#x27;t use a fast path as with get() because it is at</span><br><span class="line">    // least as common to use set() to create new entries as</span><br><span class="line">    // it is to replace existing ones, in which case, a fast</span><br><span class="line">    // path would fail more often than not.</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line"></span><br><span class="line">    for (Entry e = tab[i];</span><br><span class="line">         e != null;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        // 如果已经包含 key, 则重置 value</span><br><span class="line">        if (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果 key 为空，说明 key 被垃圾回收了，这个时候替换掉这个 key</span><br><span class="line">        if (k == null) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 在空调目处新建一个条目</span><br><span class="line">    tab[i] = new Entry(key, value);</span><br><span class="line">    int sz = ++size;</span><br><span class="line">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash(); // 如果超过了阈值就 resize 然后重新 hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>set 方法如上所示，注释已经过程比较明白了。因为每个 Entry 的 Key 是一个虚引用，所以存在被 GC 的可能。<br>此外还有 remove 方法，要注意的是删除后要重新hash。其他还有如 expungeStaleEntry 等方法都是删除陈旧条目或者是rehash。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>JDK1.8 中新增了 Suppier ，用来提供 lambda 表达式调用</p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>关于前端项目构建的一些背景知识</title>
    <url>/2024/frontend-background/</url>
    <content><![CDATA[<p>co written with chatgpt</p>
<p>了解一些前端项目用的包管理工具，构建工具，框架相关的产生的背景，点击<a href="https://chatgpt.com/share/d91f9f7f-ae6b-4fe9-a362-023699bf74be">原始对话链接</a>可以直接访问对话上下文</p>
<span id="more"></span>

<h1 id="Q1-前端编程领域，npm-npx-yarn-pnpm-cnpm-有什么联系和区别，这些命令出现的背景是啥"><a href="#Q1-前端编程领域，npm-npx-yarn-pnpm-cnpm-有什么联系和区别，这些命令出现的背景是啥" class="headerlink" title="Q1: 前端编程领域，npm npx yarn pnpm cnpm 有什么联系和区别，这些命令出现的背景是啥"></a>Q1: 前端编程领域，npm npx yarn pnpm cnpm 有什么联系和区别，这些命令出现的背景是啥</h1><p> npm、npx、yarn、pnpm 和 cnpm 都与 JavaScript 和 Node.js 的包管理和项目管理相关，它们是在不同背景下为了提高开发体验和管理 JavaScript 依赖包的工具。下面是它们的联系和区别，以及它们出现的背景。</p>
<h2 id="1-npm-Node-Package-Manager"><a href="#1-npm-Node-Package-Manager" class="headerlink" title="1. npm (Node Package Manager)"></a>1. <strong>npm (Node Package Manager)</strong></h2><p><strong>背景</strong>：</p>
<ul>
<li>npm 是 Node.js 官方的包管理工具，最早于 2010 年发布。随着 Node.js 的流行，npm 逐渐成为 JavaScript 项目管理和依赖包管理的标准工具。</li>
</ul>
<p><strong>功能</strong>：</p>
<ul>
<li>npm 用来安装、更新和卸载 Node.js 包（模块），并且管理项目的依赖（<code>package.json</code> 文件中记录的依赖项）。</li>
<li>使用 <code>npm install</code> 安装依赖。</li>
<li><code>npm publish</code> 用来发布包到 npm 官方仓库。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>npm 的历史较早，早期版本存在速度慢、冗余文件等问题，随着 npm 的版本更新，已经有所改善。</li>
</ul>
<h2 id="2-npx"><a href="#2-npx" class="headerlink" title="2. npx"></a>2. <strong>npx</strong></h2><p><strong>背景</strong>：</p>
<ul>
<li>npx 是 npm v5.2.0 版本中引入的一个工具，目的在于简化临时执行 npm 包中的 CLI 命令，而不必全局安装这些包。</li>
</ul>
<p><strong>功能</strong>：</p>
<ul>
<li>npx 允许直接从 npm 注册表执行包内的命令，而无需先使用 <code>npm install</code> 安装该包。</li>
<li>使用场景：执行像 <code>create-react-app</code> 这样的工具时，以前需要先 <code>npm install -g create-react-app</code>，而现在可以直接用 <code>npx create-react-app my-app</code>。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>减少全局安装的包数量，避免全局命令版本冲突。</li>
<li>简化了使用临时命令行工具的过程。</li>
</ul>
<h2 id="3-Yarn"><a href="#3-Yarn" class="headerlink" title="3. Yarn"></a>3. <strong>Yarn</strong></h2><p><strong>背景</strong>：</p>
<ul>
<li>Yarn 是由 Facebook 开发的一款新的包管理工具，于 2016 年发布。它是对 npm 进行改进的一个替代品，初期目标是解决 npm 在速度、依赖管理、锁定文件和并发安装上的一些缺点。</li>
</ul>
<p><strong>功能</strong>：</p>
<ul>
<li><code>yarn install</code> 用来安装项目的依赖，<code>yarn add [package]</code> 用来添加新的依赖。</li>
<li>Yarn 在并发安装包时速度较快，并且具有一致性更好的锁定机制 (<code>yarn.lock</code>)，减少依赖版本不一致的情况。</li>
<li>Yarn 还可以离线安装，已经安装过的包可以在没有网络的情况下再次安装。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>更快的依赖安装速度。</li>
<li>更加可靠的锁定机制，保证了团队中不同开发人员安装相同的依赖版本。</li>
<li>解决了 npm 中的一些历史性问题。</li>
</ul>
<h2 id="4-pnpm-Performant-npm"><a href="#4-pnpm-Performant-npm" class="headerlink" title="4. pnpm (Performant npm)"></a>4. <strong>pnpm (Performant npm)</strong></h2><p><strong>背景</strong>：</p>
<ul>
<li>pnpm 是为了解决 npm 和 Yarn 中可能出现的磁盘空间浪费问题而开发的一个工具。它通过符号链接的方式减少冗余依赖包的存储，于 2017 年发布。</li>
</ul>
<p><strong>功能</strong>：</p>
<ul>
<li>与 npm 和 Yarn 类似，pnpm 也用来安装、管理项目依赖。</li>
<li>不同的是，pnpm 通过符号链接来共享依赖包的相同版本，从而减少了重复安装同一依赖包的磁盘空间占用。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>节省磁盘空间。</li>
<li>更快的安装速度，尤其是在项目依赖较多时。</li>
<li>通过符号链接和内容寻址（content-addressable storage）提高了效率。</li>
</ul>
<h2 id="5-cnpm-China-npm"><a href="#5-cnpm-China-npm" class="headerlink" title="5. cnpm (China npm)"></a>5. <strong>cnpm (China npm)</strong></h2><p><strong>背景</strong>：</p>
<ul>
<li>cnpm 是由阿里巴巴团队开发的 npm 的一个镜像工具，目的是为了加速中国国内开发者访问 npm 仓库。</li>
</ul>
<p><strong>功能</strong>：</p>
<ul>
<li>cnpm 是 npm 的国内镜像版，功能与 npm 相同，但它的包源指向了国内的镜像服务器（例如阿里巴巴的 npm 镜像），从而提高了国内用户的包下载速度。</li>
<li>使用方式和 npm 几乎相同：<code>cnpm install</code>，<code>cnpm publish</code> 等。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>更快的包下载速度，特别是在中国大陆地区使用时，减少了网络延迟。</li>
<li>和 npm 保持功能一致，可以无缝切换。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>工具</th>
<th>主要功能</th>
<th>特点和优点</th>
<th>背景</th>
</tr>
</thead>
<tbody><tr>
<td>npm</td>
<td>Node.js 的默认包管理工具</td>
<td>管理依赖，安装&#x2F;发布包。</td>
<td>Node.js 官方工具</td>
</tr>
<tr>
<td>npx</td>
<td>npm 附带的命令执行工具</td>
<td>执行临时包命令，无需全局安装</td>
<td>为简化命令执行而生</td>
</tr>
<tr>
<td>Yarn</td>
<td>Facebook 开发的替代 npm 工具</td>
<td>更快的安装速度、可靠的锁定机制、离线安装支持</td>
<td>为提高 npm 的性能和一致性</td>
</tr>
<tr>
<td>pnpm</td>
<td>高效的包管理工具</td>
<td>通过符号链接减少磁盘空间占用，提高安装速度</td>
<td>为减少磁盘空间占用</td>
</tr>
<tr>
<td>cnpm</td>
<td>npm 的中国镜像版本</td>
<td>国内访问更快</td>
<td>提升国内开发者的包下载体验</td>
</tr>
</tbody></table>
<p>这些工具在前端开发过程中紧密相关，它们的出现和发展都是为了解决开发者在实际使用过程中遇到的依赖管理、性能和效率问题。</p>
<h1 id="Q2-webpack-vite-babel的功能和历史背景呢"><a href="#Q2-webpack-vite-babel的功能和历史背景呢" class="headerlink" title="Q2: webpack vite babel的功能和历史背景呢"></a>Q2: webpack vite babel的功能和历史背景呢</h1><p>Webpack、Vite 和 Babel 是 JavaScript 生态系统中常用的构建工具和编译器，它们帮助开发者打包、编译和优化前端代码。下面是它们的功能和历史背景。</p>
<h2 id="1-Webpack"><a href="#1-Webpack" class="headerlink" title="1. Webpack"></a>1. <strong>Webpack</strong></h2><p><strong>背景</strong>：</p>
<ul>
<li>Webpack 于 2012 年由 Tobias Koppers 开发，最初的目的是解决前端模块化的问题。随着前端应用复杂度的提升，开发者需要将 JavaScript、CSS、图片等资源组织成模块并打包，以提高加载性能和开发体验。</li>
<li>Webpack 的出现大大改变了前端开发者的工作方式，成为模块打包工具的行业标准。</li>
</ul>
<p><strong>功能</strong>：</p>
<ul>
<li><strong>模块打包</strong>：Webpack 是一个静态模块打包器，它可以将不同类型的文件（JavaScript、CSS、图片等）视作模块，并通过依赖图（dependency graph）将这些模块打包成一个或多个文件。</li>
<li><strong>代码分割</strong>：Webpack 支持代码分割（Code Splitting），使应用按需加载，减少初次加载时间。</li>
<li><strong>Tree Shaking</strong>：Webpack 通过删除未使用的代码来优化输出文件。</li>
<li><strong>插件系统</strong>：Webpack 有强大的插件系统，支持定制化构建过程，例如压缩代码、热更新（HMR）等。</li>
<li><strong>Loader 机制</strong>：通过加载器（Loader），Webpack 可以处理非 JavaScript 的文件，例如 <code>css-loader</code> 用来加载 CSS 文件，<code>babel-loader</code> 用来将 ES6+ 代码转为兼容性更好的 ES5 代码。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>Webpack 适合大型复杂的前端项目，提供了灵活的配置选项和强大的插件生态。</li>
<li>它帮助开发者将现代 JavaScript 和资源打包优化，提高性能。</li>
</ul>
<h2 id="2-Vite"><a href="#2-Vite" class="headerlink" title="2. Vite"></a>2. <strong>Vite</strong></h2><p><strong>背景</strong>：</p>
<ul>
<li>Vite 是由 Vue.js 的作者尤雨溪（Evan You）在 2020 年开发的，它的目标是解决传统构建工具（如 Webpack）在开发过程中速度慢、配置复杂的问题，尤其是在开发大型单页面应用（SPA）时，重新构建和打包的速度会随着项目规模增大而变慢。</li>
<li>Vite 最初为 Vue 项目服务，但随着其发展，现在可以支持多种前端框架，包括 React、Svelte 等。</li>
</ul>
<p><strong>功能</strong>：</p>
<ul>
<li><strong>快速开发服务器</strong>：Vite 使用原生的 ES 模块（ESM），不需要像 Webpack 那样在开发时打包整个应用，开发服务器会根据浏览器请求的模块进行按需加载，提升了开发体验和速度。</li>
<li><strong>即时热更新（HMR）</strong>：在开发过程中，Vite 提供了快速的热更新机制，保证开发者在代码变更时可以即时看到效果，而无需整个页面刷新。</li>
<li><strong>生产环境构建</strong>：在生产环境中，Vite 依然使用类似 Rollup 的打包器来生成优化后的静态文件，保证生产构建的性能和文件大小。</li>
<li><strong>支持现代 JavaScript</strong>：Vite 直接支持现代 JavaScript 语法，不需要像 Babel 这样的工具将代码降级为 ES5。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>开发速度极快，特别适用于现代浏览器支持的 ES 模块化。</li>
<li>配置简单，与传统工具相比，开发环境的启动速度快、实时反馈好。</li>
</ul>
<h2 id="3-Babel"><a href="#3-Babel" class="headerlink" title="3. Babel"></a>3. <strong>Babel</strong></h2><p><strong>背景</strong>：</p>
<ul>
<li>Babel 最早于 2014 年由 Sebastian McKenzie 发布，最初名为 6to5，后更名为 Babel。其初衷是为了让开发者能够使用最新的 JavaScript 语法和特性，而不必担心浏览器的兼容性问题。</li>
<li>随着 ES6（ES2015）标准的发布，Babel 成为将现代 JavaScript 特性编译为 ES5 等早期版本的必要工具。</li>
</ul>
<p><strong>功能</strong>：</p>
<ul>
<li><strong>JavaScript 编译器</strong>：Babel 是一个编译器，将现代 JavaScript（ES6+）编译为兼容的旧版本 JavaScript，以便在旧版浏览器中运行。</li>
<li><strong>插件系统</strong>：Babel 有丰富的插件系统，开发者可以根据需要选择编译的特性，如箭头函数、解构赋值、类（class）语法等。</li>
<li><strong>Polyfill</strong>：Babel 还可以通过引入 polyfill 来模拟现代 JavaScript API，如 <code>Promise</code>、<code>Set</code> 等，从而让旧版浏览器支持这些新特性。</li>
<li><strong>语法扩展</strong>：Babel 也支持将非标准语法编译为标准 JavaScript，如 JSX（React 的语法扩展）编译为 JavaScript。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>Babel 让开发者可以使用最新的 JavaScript语法和特性，而不必担心浏览器兼容性问题，从而推动了 JavaScript 语言的发展和新特性的快速应用。</li>
<li>通过其插件系统，Babel 可以灵活配置以满足项目需求，如使用不同的 JavaScript 语法版本或自定义的代码转换。</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>工具</th>
<th>主要功能</th>
<th>主要背景</th>
</tr>
</thead>
<tbody><tr>
<td>Webpack</td>
<td>模块打包、代码分割、Tree Shaking、插件扩展</td>
<td>解决前端模块化需求，尤其是对复杂项目的依赖管理和性能优化。</td>
</tr>
<tr>
<td>Vite</td>
<td>快速开发服务器、热更新、生产环境打包</td>
<td>提高开发体验，减少 Webpack 复杂配置和开发时的构建速度瓶颈，支持现代浏览器。</td>
</tr>
<tr>
<td>Babel</td>
<td>将现代 JavaScript 编译为旧版本、插件扩展</td>
<td>让开发者能够使用最新的 JavaScript 特性，解决不同浏览器版本的兼容性问题。</td>
</tr>
</tbody></table>
<p>这些工具在各自领域解决了 JavaScript 生态系统中的不同问题，它们为前端开发提供了灵活、高效的解决方案，极大地提升了开发者的工作效率和项目性能。</p>
<h1 id="Q3-一个简单的react应用，必须通过webpack或者vite打包编译成静态文件才能部署发静态服务器上吗"><a href="#Q3-一个简单的react应用，必须通过webpack或者vite打包编译成静态文件才能部署发静态服务器上吗" class="headerlink" title="Q3: 一个简单的react应用，必须通过webpack或者vite打包编译成静态文件才能部署发静态服务器上吗"></a>Q3: 一个简单的react应用，必须通过webpack或者vite打包编译成静态文件才能部署发静态服务器上吗</h1><p>一个简单的 React 应用<strong>不必须</strong>通过 Webpack 或 Vite 打包编译成静态文件才能部署到静态服务器上，但使用这些工具能带来很多好处，如优化和提升性能。你也可以通过其他方式来运行和部署 React 应用，不过 Webpack 和 Vite 是常见和推荐的方式，原因如下：</p>
<h2 id="为什么通常使用-Webpack-或-Vite？"><a href="#为什么通常使用-Webpack-或-Vite？" class="headerlink" title="为什么通常使用 Webpack 或 Vite？"></a>为什么通常使用 Webpack 或 Vite？</h2><ol>
<li><strong>模块打包</strong>：React 应用通常由多个组件和文件组成，Webpack 和 Vite 会将这些模块打包成一个或多个文件，以便浏览器能高效加载。</li>
<li><strong>代码优化</strong>：这些工具可以自动优化代码，如代码分割（Code Splitting）、Tree Shaking（移除无用代码）、压缩和混淆（Minification）等，提高应用的加载速度。</li>
<li><strong>现代 JavaScript 语法</strong>：React 通常使用 ES6+ 语法，像 JSX、模块化等特性。如果没有使用打包工具（如 Webpack、Vite），浏览器不能直接识别 JSX 和一些现代 JavaScript 特性，需要 Babel 等工具进行编译。</li>
<li><strong>生产环境构建</strong>：打包工具会根据环境生成适当的代码，例如在生产环境下去掉调试工具，压缩代码，使应用更加轻量。</li>
</ol>
<h2 id="不用-Webpack-Vite-的方式"><a href="#不用-Webpack-Vite-的方式" class="headerlink" title="不用 Webpack&#x2F;Vite 的方式"></a>不用 Webpack&#x2F;Vite 的方式</h2><p>如果你不使用 Webpack 或 Vite，也可以使用其他方法在静态服务器上运行 React 应用。以下是几种替代方法：</p>
<ol>
<li><strong>使用 <strong><code>&lt;script&gt;</code></strong> 标签直接加载 React 和 Babel</strong>：<ul>
<li>你可以通过 <code>&lt;script&gt;</code> 标签直接在 HTML 文件中引入 React 和 Babel 来运行简单的 React 应用，不需要任何打包工具。但这种方式适合非常简单的、学习性质的项目，而不是生产级应用。</li>
<li>代码示例：</li>
</ul>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>React App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, React!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>- **缺点**：
    * 不支持模块化管理代码。
    * 没有代码优化，加载速度慢。
    * 依赖外部 CDN，在生产环境下性能较差。
</code></pre>
<ol start="2">
<li><strong>使用纯 HTML + JavaScript 模板（无需打包）</strong>：<ul>
<li>你可以使用像 Parcel 这样不需要复杂配置的打包工具，它会自动处理文件依赖，但它仍然是一个打包工具，只是更加简单。</li>
<li>你可以通过 <code>create-react-app</code> 工具生成 React 应用，自动配置 Webpack，并提供一个简单的开发和打包环境。</li>
</ul>
</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>虽然技术上不需要通过 Webpack 或 Vite 打包编译成静态文件，你可以使用简单的 <code>&lt;script&gt;</code> 标签加载 React，但这只适用于非常简单的应用和开发环境。对于生产环境，Webpack、Vite 或类似工具可以带来更好的性能和开发体验，因此在实际应用中非常推荐使用这些工具来打包编译你的 React 应用。</p>
<h1 id="Q4-模块化的react应用就一定需要打包工具吗"><a href="#Q4-模块化的react应用就一定需要打包工具吗" class="headerlink" title="Q4: 模块化的react应用就一定需要打包工具吗"></a>Q4: 模块化的react应用就一定需要打包工具吗</h1><p>是的，<strong>模块化的 React 应用</strong>在大多数情况下<strong>需要打包工具</strong>，例如 Webpack、Vite 或其他类似的工具。原因如下：</p>
<h2 id="1-浏览器对模块的支持有限"><a href="#1-浏览器对模块的支持有限" class="headerlink" title="1. 浏览器对模块的支持有限"></a>1. <strong>浏览器对模块的支持有限</strong></h2><ul>
<li>虽然现代浏览器支持原生的 ES 模块（ES Modules，<code>&lt;script type=&quot;module&quot;&gt;</code>），但这种原生模块化支持仍然有限，特别是在涉及非 JavaScript 资源（例如 CSS、图片）时，浏览器无法直接加载这些模块。</li>
<li>如果你的 React 应用中使用了例如 <code>import</code>、<code>export</code> 等现代 JavaScript 模块语法，浏览器只能处理 JavaScript 模块，但无法处理诸如 JSX、CSS Modules 等扩展语言或文件格式。</li>
</ul>
<h2 id="2-JSX-语法需要编译"><a href="#2-JSX-语法需要编译" class="headerlink" title="2. JSX 语法需要编译"></a>2. <strong>JSX 语法需要编译</strong></h2><ul>
<li>React 的 JSX 语法并不是原生 JavaScript，浏览器无法直接解析和运行 JSX 代码。它需要通过 Babel 等编译工具将 JSX 转换为普通的 JavaScript 函数调用，例如将：</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<p>转换为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;Hello, world!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果不使用打包工具来处理这些转换，浏览器将无法运行包含 JSX 的模块化 React 应用。</li>
</ul>
<h2 id="3-处理依赖和模块打包"><a href="#3-处理依赖和模块打包" class="headerlink" title="3. 处理依赖和模块打包"></a>3. <strong>处理依赖和模块打包</strong></h2><ul>
<li>一个模块化的 React 应用往往会有许多依赖（例如 React、ReactDOM，甚至第三方库如 Lodash、Axios 等）。打包工具可以将所有依赖和模块打包成一个或多个文件，确保它们按照依赖关系正确加载。</li>
<li>如果没有打包工具，浏览器需要单独加载每一个模块文件，这会导致更多的 HTTP 请求，影响应用的性能。打包工具通过“代码分割”和“依赖树优化”等技术减少不必要的加载，提升性能。</li>
</ul>
<h2 id="4-代码优化和压缩"><a href="#4-代码优化和压缩" class="headerlink" title="4. 代码优化和压缩"></a>4. <strong>代码优化和压缩</strong></h2><ul>
<li>在生产环境中，打包工具可以对代码进行优化，如移除未使用的代码（Tree Shaking）、压缩代码（Minification）等，从而减少文件体积，加快页面加载速度。这些功能在原生模块加载中是无法实现的。</li>
<li>例如，Webpack 和 Vite 都支持将你的 React 应用拆分成多个按需加载的代码块（Code Splitting），从而提高页面加载速度。</li>
</ul>
<h2 id="5-处理非-JavaScript-资源"><a href="#5-处理非-JavaScript-资源" class="headerlink" title="5. 处理非 JavaScript 资源"></a>5. <strong>处理非 JavaScript 资源</strong></h2><ul>
<li>在现代的前端项目中，除了 JavaScript 代码，你还需要引入其他类型的资源文件，如 CSS、图片、字体等。打包工具允许你在 JavaScript 代码中直接导入这些资源，并将它们与代码一起打包。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./styles.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> logo <span class="keyword">from</span> <span class="string">&#x27;./logo.png&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>浏览器无法直接理解这些导入，打包工具会将这些资源处理为静态文件，并生成相应的引用路径。</li>
</ul>
<h2 id="6-跨浏览器兼容性"><a href="#6-跨浏览器兼容性" class="headerlink" title="6. 跨浏览器兼容性"></a>6. <strong>跨浏览器兼容性</strong></h2><ul>
<li>即使你使用的是现代浏览器的原生模块化支持，不同浏览器对 JavaScript 的新特性支持不完全一致。打包工具通常会结合 Babel 等工具，将现代 JavaScript 语法编译成适用于所有主流浏览器的旧版 JavaScript，以确保兼容性。</li>
</ul>
<h2 id="没有打包工具的方案和局限性"><a href="#没有打包工具的方案和局限性" class="headerlink" title="没有打包工具的方案和局限性"></a>没有打包工具的方案和局限性</h2><p>虽然理论上你可以在一个非常简单的环境中直接使用浏览器的 ES 模块支持，并通过 CDN 来加载 React 和其他依赖，但这在以下场景中有明显的局限性：</p>
<ul>
<li>浏览器的模块加载是逐个加载文件，性能差。</li>
<li>没有代码压缩和优化，文件体积大。</li>
<li>无法使用 JSX、CSS Modules 等 React 常见功能。</li>
<li>对于复杂项目，缺乏依赖管理和代码分割等高级功能。</li>
</ul>
<h2 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h2><p><strong>模块化的 React 应用几乎总是需要打包工具</strong>，尤其是当你使用了 JSX 语法、模块依赖、CSS 和其他静态资源时。打包工具不仅帮助解决了浏览器的限制，还能优化应用性能、处理依赖和模块，提供更好的开发和部署体验。</p>
<h1 id="Q5-jsx语法编译成js文件一定需要Babel吗"><a href="#Q5-jsx语法编译成js文件一定需要Babel吗" class="headerlink" title="Q5: jsx语法编译成js文件一定需要Babel吗"></a>Q5: jsx语法编译成js文件一定需要Babel吗</h1><p>是的，<strong>模块化的 React 应用</strong>在大多数情况下<strong>需要打包工具</strong>，例如 Webpack、Vite 或其他类似的工具。原因如下：</p>
<h2 id="1-浏览器对模块的支持有限-1"><a href="#1-浏览器对模块的支持有限-1" class="headerlink" title="1. 浏览器对模块的支持有限"></a>1. <strong>浏览器对模块的支持有限</strong></h2><ul>
<li>虽然现代浏览器支持原生的 ES 模块（ES Modules，<code>&lt;script type=&quot;module&quot;&gt;</code>），但这种原生模块化支持仍然有限，特别是在涉及非 JavaScript 资源（例如 CSS、图片）时，浏览器无法直接加载这些模块。</li>
<li>如果你的 React 应用中使用了例如 <code>import</code>、<code>export</code> 等现代 JavaScript 模块语法，浏览器只能处理 JavaScript 模块，但无法处理诸如 JSX、CSS Modules 等扩展语言或文件格式。</li>
</ul>
<h2 id="2-JSX-语法需要编译-1"><a href="#2-JSX-语法需要编译-1" class="headerlink" title="2. JSX 语法需要编译"></a>2. <strong>JSX 语法需要编译</strong></h2><ul>
<li>React 的 JSX 语法并不是原生 JavaScript，浏览器无法直接解析和运行 JSX 代码。它需要通过 Babel 等编译工具将 JSX 转换为普通的 JavaScript 函数调用，例如将：</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<p>转换为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;Hello, world!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果不使用打包工具来处理这些转换，浏览器将无法运行包含 JSX 的模块化 React 应用。</li>
</ul>
<h2 id="3-处理依赖和模块打包-1"><a href="#3-处理依赖和模块打包-1" class="headerlink" title="3. 处理依赖和模块打包"></a>3. <strong>处理依赖和模块打包</strong></h2><ul>
<li>一个模块化的 React 应用往往会有许多依赖（例如 React、ReactDOM，甚至第三方库如 Lodash、Axios 等）。打包工具可以将所有依赖和模块打包成一个或多个文件，确保它们按照依赖关系正确加载。</li>
<li>如果没有打包工具，浏览器需要单独加载每一个模块文件，这会导致更多的 HTTP 请求，影响应用的性能。打包工具通过“代码分割”和“依赖树优化”等技术减少不必要的加载，提升性能。</li>
</ul>
<h2 id="4-代码优化和压缩-1"><a href="#4-代码优化和压缩-1" class="headerlink" title="4. 代码优化和压缩"></a>4. <strong>代码优化和压缩</strong></h2><ul>
<li>在生产环境中，打包工具可以对代码进行优化，如移除未使用的代码（Tree Shaking）、压缩代码（Minification）等，从而减少文件体积，加快页面加载速度。这些功能在原生模块加载中是无法实现的。</li>
<li>例如，Webpack 和 Vite 都支持将你的 React 应用拆分成多个按需加载的代码块（Code Splitting），从而提高页面加载速度。</li>
</ul>
<h2 id="5-处理非-JavaScript-资源-1"><a href="#5-处理非-JavaScript-资源-1" class="headerlink" title="5. 处理非 JavaScript 资源"></a>5. <strong>处理非 JavaScript 资源</strong></h2><ul>
<li>在现代的前端项目中，除了 JavaScript 代码，你还需要引入其他类型的资源文件，如 CSS、图片、字体等。打包工具允许你在 JavaScript 代码中直接导入这些资源，并将它们与代码一起打包。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./styles.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> logo <span class="keyword">from</span> <span class="string">&#x27;./logo.png&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>浏览器无法直接理解这些导入，打包工具会将这些资源处理为静态文件，并生成相应的引用路径。</li>
</ul>
<h2 id="6-跨浏览器兼容性-1"><a href="#6-跨浏览器兼容性-1" class="headerlink" title="6. 跨浏览器兼容性"></a>6. <strong>跨浏览器兼容性</strong></h2><ul>
<li>即使你使用的是现代浏览器的原生模块化支持，不同浏览器对 JavaScript 的新特性支持不完全一致。打包工具通常会结合 Babel 等工具，将现代 JavaScript 语法编译成适用于所有主流浏览器的旧版 JavaScript，以确保兼容性。</li>
</ul>
<h2 id="没有打包工具的方案和局限性-1"><a href="#没有打包工具的方案和局限性-1" class="headerlink" title="没有打包工具的方案和局限性"></a>没有打包工具的方案和局限性</h2><p>虽然理论上你可以在一个非常简单的环境中直接使用浏览器的 ES 模块支持，并通过 CDN 来加载 React 和其他依赖，但这在以下场景中有明显的局限性：</p>
<ul>
<li>浏览器的模块加载是逐个加载文件，性能差。</li>
<li>没有代码压缩和优化，文件体积大。</li>
<li>无法使用 JSX、CSS Modules 等 React 常见功能。</li>
<li>对于复杂项目，缺乏依赖管理和代码分割等高级功能。</li>
</ul>
<h2 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h2><p><strong>模块化的 React 应用几乎总是需要打包工具</strong>，尤其是当你使用了 JSX 语法、模块依赖、CSS 和其他静态资源时。打包工具不仅帮助解决了浏览器的限制，还能优化应用性能、处理依赖和模块，提供更好的开发和部署体验。</p>
<h1 id="Q6-create-react-app-创建一个简单的react应用模版外，vite也可以用来创建类似react模版吗"><a href="#Q6-create-react-app-创建一个简单的react应用模版外，vite也可以用来创建类似react模版吗" class="headerlink" title="Q6: create react app 创建一个简单的react应用模版外，vite也可以用来创建类似react模版吗"></a>Q6: create react app 创建一个简单的react应用模版外，vite也可以用来创建类似react模版吗</h1><p>是的，<strong>Vite</strong> 也可以用来创建一个类似于 <code>create-react-app</code> 的 React 应用模板，而且相比于 <code>create-react-app</code>，Vite 的开发体验更快，尤其是在大型项目中，它的热更新和启动速度都更快。</p>
<h2 id="使用-Vite-创建-React-项目"><a href="#使用-Vite-创建-React-项目" class="headerlink" title="使用 Vite 创建 React 项目"></a>使用 Vite 创建 React 项目</h2><p>Vite 提供了直接创建 React 模板的选项，创建过程非常简单。下面是具体步骤：</p>
<h3 id="1-全局安装-Vite"><a href="#1-全局安装-Vite" class="headerlink" title="1. 全局安装 Vite"></a>1. <strong>全局安装 Vite</strong></h3><p>   首先，你可以使用 npm、yarn 或 pnpm 全局安装 Vite：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm create vite@latest</span><br></pre></td></tr></table></figure>

<h3 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2. 创建项目"></a>2. <strong>创建项目</strong></h3><p>   运行安装命令后，Vite 会提示你选择一个项目名称和模板。选择 “React” 模板进行创建：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm create vite@latest my-react-app</span><br></pre></td></tr></table></figure>

<p>   在项目创建过程中，Vite 会提示你选择想要的模板，可以选择 “React” 或 “React + TypeScript”。</p>
<p>   例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">? Select a framework: » - Use arrow-keys. Return to submit.</span><br><span class="line">  vanilla</span><br><span class="line">  vue</span><br><span class="line">  react</span><br><span class="line">  preact</span><br><span class="line">  lit</span><br><span class="line">  svelte</span><br></pre></td></tr></table></figure>

<p>   选择 <code>react</code> 后，Vite 将创建一个 React 项目。</p>
<h3 id="3-安装依赖"><a href="#3-安装依赖" class="headerlink" title="3. 安装依赖"></a>3. <strong>安装依赖</strong></h3><p>   进入到项目文件夹中，并安装依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-react-app</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h3 id="4-启动开发服务器"><a href="#4-启动开发服务器" class="headerlink" title="4. 启动开发服务器"></a>4. <strong>启动开发服务器</strong></h3><p>   安装完成后，启动开发服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>   启动成功后，Vite 的开发服务器将运行在 <code>http://localhost:5173</code>，你可以在浏览器中访问这个地址查看 React 应用。</p>
<h2 id="Vite-vs-Create-React-App-CRA"><a href="#Vite-vs-Create-React-App-CRA" class="headerlink" title="Vite vs Create React App (CRA)"></a>Vite vs Create React App (CRA)</h2><p>Vite 和 <code>create-react-app</code> (CRA) 都能用来创建 React 应用，但它们的底层架构和开发体验有一些不同：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Vite</th>
<th>Create React App (CRA)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>开发服务器启动速度</strong></td>
<td>启动速度极快，即使在大型项目中表现优异</td>
<td>对于大型项目，启动速度相对较慢</td>
</tr>
<tr>
<td><strong>构建工具</strong></td>
<td>使用 esbuild 作为开发服务器，Rollup 打包</td>
<td>使用 Webpack 作为打包工具</td>
</tr>
<tr>
<td><strong>热模块替换 (HMR)</strong></td>
<td>超快速的热更新，即时反应</td>
<td>HMR 支持较好，但在复杂项目中可能较慢</td>
</tr>
<tr>
<td><strong>初始配置复杂度</strong></td>
<td>默认配置较简单，但灵活度高</td>
<td>默认配置较全面，但定制化需要复杂配置</td>
</tr>
<tr>
<td><strong>插件支持</strong></td>
<td>插件系统轻量但功能强大</td>
<td>CRA 的插件（如 react-scripts）功能丰富</td>
</tr>
<tr>
<td><strong>生态系统支持</strong></td>
<td>正在迅速成长，特别适合现代开发需求</td>
<td>社区成熟，广泛使用，插件支持完善</td>
</tr>
</tbody></table>
<h2 id="何时选择-Vite？"><a href="#何时选择-Vite？" class="headerlink" title="何时选择 Vite？"></a>何时选择 Vite？</h2><ul>
<li>如果你需要一个 <strong>快速的开发体验</strong>，特别是在大型项目中，Vite 的启动速度和热模块替换会比 CRA 快很多。</li>
<li>如果你想要一个现代的、<strong>轻量的开发工具链</strong>，并且不需要过多的复杂配置，Vite 是一个很好的选择。</li>
<li>对于需要使用 ES 模块（ESM）和现代浏览器环境的项目，Vite 是更好的选择，因为它使用现代浏览器支持的 ES 模块直接在开发环境中进行模块化处理，而不是通过打包。</li>
</ul>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>Vite 可以轻松创建类似 <code>create-react-app</code> 的 React 应用模板，并且由于其性能和开发体验的提升，Vite 越来越受欢迎。特别是对于现代 Web 开发，Vite 提供了更快的启动时间和更流畅的开发流程。</p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>chatgpt</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Next 修改 CSS 自定义显示效果</title>
    <url>/2024/hexo-next-custom-style/</url>
    <content><![CDATA[<p>hexo next 这个博客主题挺流行的，但是有一些显示效果不是很喜欢，一般来说我们可以 git clone 下来 next 这个主题源码再进行修改相应的样式，不过 next 提供了自定义 css 的能力，通过提供一个自定义的 style 文件就可以相应的修改显示效果，参考官方链接的使用方法<a href="https://theme-next.js.org/docs/advanced-settings/custom-files#Hide-Keep-on-posting-in-Archive-Page">Custom Files</a>，下面分享一下我做的一些修改。</p>
<span id="more"></span>
<h1 id="如何修改"><a href="#如何修改" class="headerlink" title="如何修改"></a>如何修改</h1><h2 id="定位CSS"><a href="#定位CSS" class="headerlink" title="定位CSS"></a>定位CSS</h2><p>这个其实通过浏览器的开发者工具页面可以找到，我们找到相应元素的 css 类，然后可以自行调整其中的属性值达到我们<br><img src="/2024/hexo-next-custom-style/find-target.png" alt="image.png"></p>
<h2 id="next-style-配置"><a href="#next-style-配置" class="headerlink" title="next style 配置"></a>next style 配置</h2><p>参考 <a href="https://theme-next.js.org/docs/advanced-settings/custom-files#Hide-Keep-on-posting-in-Archive-Page">Custom Files</a>，在 <code>source/_data/styles.styl</code>中添加 css<br>添加类选择器的时候最好按照浏览器显示的类选择器一起 copy 下来，如下所示<br><img src="/2024/hexo-next-custom-style/css-selector.png" alt="image.png"><br>然后在 style 文件中添加修改项<br><img src="/2024/hexo-next-custom-style/modify-css.png" alt="image.png"></p>
<h1 id="我的修改"><a href="#我的修改" class="headerlink" title="我的修改"></a>我的修改</h1><p><strong>注：本文的修改都是基于 NexT.Mist 主题调整的, 主页 post 调整只在 NexT.Mist 生效，archive 页的调整基本都适用于其他 NexT 主题</strong></p>
<h2 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h2><h3 id="post-更加紧凑"><a href="#post-更加紧凑" class="headerlink" title="post 更加紧凑"></a>post 更加紧凑</h3><p>调整后<br><img src="/2024/hexo-next-custom-style/post.png" alt="调整后" title="调整后"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-block</span><span class="selector-pseudo">:first</span>-of-type &#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-block</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:first</span>-of-type) &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来的 post 之间间隔太大了，首页点进去感觉过于稀疏了</p>
<h3 id="翻页按键边缘与-post-边缘对齐，翻页按键与-post-间距缩小"><a href="#翻页按键边缘与-post-边缘对齐，翻页按键与-post-间距缩小" class="headerlink" title="翻页按键边缘与 post 边缘对齐，翻页按键与 post 间距缩小"></a>翻页按键边缘与 post 边缘对齐，翻页按键与 post 间距缩小</h3><p>调整前，间距大，按钮边缘没对齐</p>
<!--![调整前](/2024/hexo-next-custom-style/pagination-before.png "调整前，间距大，按钮边缘没对齐")-->
<p><img src="/2024/hexo-next-custom-style/pagination-before.png" width=600 style="float: left; width='50%'"><div style="clear: both;"></div><br>调整后</p>
<!--![调整后](/2024/hexo-next-custom-style/pagination-after.png "调整后")-->
<p><img src="/2024/hexo-next-custom-style/pagination-after.png" style="float: left; width='50%'"><div style="clear: both;"></div></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 分页  </span><br><span class="line"><span class="selector-class">.pagination</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">60px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.pagination</span> <span class="selector-class">.prev</span>, <span class="selector-class">.pagination</span> <span class="selector-class">.next</span>, <span class="selector-class">.pagination</span> <span class="selector-class">.page-number</span>, <span class="selector-class">.pagination</span> <span class="selector-class">.space</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: -<span class="number">1px</span> <span class="number">10px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归档页面"><a href="#归档页面" class="headerlink" title="归档页面"></a>归档页面</h2><h3 id="去掉归档页的文档统计"><a href="#去掉归档页的文档统计" class="headerlink" title="去掉归档页的文档统计"></a>去掉归档页的文档统计</h3><p><img src="/2024/hexo-next-custom-style/archive-title.png" alt="image.png"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.posts-collapse</span> <span class="selector-class">.post-content</span> <span class="selector-class">.collection-title</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="年份缩进，标题间距调整，标题字体放大，竖线改细等"><a href="#年份缩进，标题间距调整，标题字体放大，竖线改细等" class="headerlink" title="年份缩进，标题间距调整，标题字体放大，竖线改细等"></a>年份缩进，标题间距调整，标题字体放大，竖线改细等</h3><p>调整前<br><img src="/2024/hexo-next-custom-style/archive-list-before.png" alt="调整前" title="调整前"><br>调整后<br><img src="/2024/hexo-next-custom-style/archive-list-after.png" alt="调整后" title="调整后"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 竖线是这个 before 元素控制的，改细，同时稍微一动位置与标题栏前的圆心对齐</span><br><span class="line">// 左侧的竖线原来太抢眼了，这里弱化竖线的视觉效果</span><br><span class="line"><span class="selector-class">.posts-collapse</span> <span class="selector-class">.post-content</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--archive-post-content-before-color)</span><br><span class="line">  margin-left: -<span class="number">0.5px</span></span><br><span class="line">  top: <span class="number">1em</span></span><br><span class="line">  width: <span class="number">1px</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 年份缩进，看起来就更有层次感</span><br><span class="line"><span class="selector-class">.posts-collapse</span> <span class="selector-class">.post-content</span> <span class="selector-class">.collection-year</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">40px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 去掉掉年份前的圆点</span><br><span class="line"><span class="selector-class">.posts-collapse</span> <span class="selector-class">.post-content</span> <span class="selector-class">.collection-year</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调整归档页面的上的间距</span><br><span class="line"><span class="selector-class">.posts-collapse</span> <span class="selector-class">.post-content</span> <span class="selector-class">.collection-header</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 文档标题字体整体放大，强调一下视觉效果</span><br><span class="line"><span class="selector-class">.posts-collapse</span> <span class="selector-class">.post-content</span> <span class="selector-class">.post-header</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.1em</span></span><br><span class="line">&#125;</span><br><span class="line">// 文档标题前的日期字体方法，原来其实是个缩小效果，这么写之后就取消了缩小效果</span><br><span class="line"><span class="selector-class">.posts-collapse</span> <span class="selector-class">.post-content</span> <span class="selector-class">.post-meta-container</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: inherit; <span class="comment">/* or use initial or unset */</span></span><br><span class="line">&#125;</span><br><span class="line">// 减小页面最上方的空隙</span><br><span class="line"><span class="selector-class">.archive</span> <span class="selector-class">.post-block</span><span class="selector-pseudo">:first</span>-of-type &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="竖线的夜间模式"><a href="#竖线的夜间模式" class="headerlink" title="竖线的夜间模式"></a>竖线的夜间模式</h3><p>调整前<br><img src="/2024/hexo-next-custom-style/darkmode-before.png" alt="调整前" title="调整前"><br>调整后<br><img src="/2024/hexo-next-custom-style/darkmode-after.png" alt="调整后" title="调整后"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attr">--archive-post-content-before-color</span>: <span class="number">#f5f5f5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (hexo-config(&#x27;darkmode&#x27;)) &#123;</span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme</span>: dark) &#123;</span><br><span class="line">    <span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">      <span class="attr">--archive-post-content-before-color</span>: <span class="number">#454545</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这里竖线的颜色使用到了 css 的变量，然后在 <span class="selector-pseudo">:root</span> 上面定义了日间和夜间模式使用的颜色值</span><br><span class="line">// 这个定义变量的方式从next代码里趴出来的</span><br><span class="line"><span class="selector-class">.posts-collapse</span> <span class="selector-class">.post-content</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--archive-post-content-before-color)</span><br><span class="line">  margin-left: -<span class="number">0.5px</span></span><br><span class="line">  top: <span class="number">1em</span></span><br><span class="line">  width: <span class="number">1px</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 年份数量统计有背景色，这里取消掉</span><br><span class="line"><span class="selector-class">.posts-collapse</span> <span class="selector-class">.post-content</span> <span class="selector-class">.collection-year</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/next-theme/hexo-theme-next/blob/master/source/css/_colors.styl">next 定义的 css color 变量</a></p>
<h3 id="文档标题添加动画"><a href="#文档标题添加动画" class="headerlink" title="文档标题添加动画"></a>文档标题添加动画</h3><p>调整前<br><img src="/2024/hexo-next-custom-style/hover-before.gif" alt="调整前" title="调整前"><br>调整后<br><img src="/2024/hexo-next-custom-style/hover-after.gif" alt="调整后" title="调整后"><br>可以看出来调整后的选中效果明显更好了</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 归档页 title 添加选中的加粗放大效果和动画</span><br><span class="line"><span class="selector-class">.posts-collapse</span> <span class="selector-class">.post-content</span> <span class="selector-class">.post-title</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: font-size <span class="number">0.1s</span> ease, font-weight <span class="number">0.1s</span> ease; <span class="comment">/* 添加过渡动画 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.posts-collapse</span> <span class="selector-class">.post-content</span> <span class="selector-class">.post-title</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.1em</span>; <span class="comment">/* 放大字体大小，1.1em 表示放大 10% */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个小技巧是，在调试的时候可以通过图示的方法显示 hover 后的显示效果，这点击后可以看到加粗<br><img src="/2024/hexo-next-custom-style/hover-debug.png" alt="image.png"></p>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>原始主题超链接与正文文字颜色相近，仅仅添加一个比较浅的下划线，如果想改超链接的显示颜色，可以添加如下代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attr">--post-body-link-color</span>: <span class="number">#b84848</span></span><br><span class="line">  --post-body-link-hover-color: <span class="number">#db5a5a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (hexo-config(&#x27;darkmode&#x27;)) &#123;</span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme</span>: dark) &#123;</span><br><span class="line">    <span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">      <span class="attr">--post-body-link-color</span>: <span class="number">#c5603e</span></span><br><span class="line">      --post-body-link-hover-color: <span class="number">#e5724b</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改正文中的超链接颜色,但不修改阅读原文的链接颜色</span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">a</span><span class="selector-pseudo">:not</span>(<span class="selector-class">.btn</span>) &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--post-body-link-color) //超链接显示颜色</span><br><span class="line">  border-bottom-color: <span class="built_in">var</span>(--post-body-link-color)</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">var</span>(--post-body-link-hover-color);  //鼠标移动上去后超链接颜色</span><br><span class="line">    <span class="attribute">border-bottom-color</span>: <span class="built_in">var</span>(--post-body-link-hover-color)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="最后附上完整的修改"><a href="#最后附上完整的修改" class="headerlink" title="最后附上完整的修改"></a>最后附上完整的修改</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attr">--archive-post-content-before-color</span>: <span class="number">#f5f5f5</span></span><br><span class="line">  --post-body-link-color: <span class="number">#b84848</span></span><br><span class="line">  --post-body-link-hover-color: <span class="number">#db5a5a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (hexo-config(&#x27;darkmode&#x27;)) &#123;</span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme</span>: dark) &#123;</span><br><span class="line">    <span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">      <span class="attr">--archive-post-content-before-color</span>: <span class="number">#454545</span></span><br><span class="line">      --post-body-link-color: <span class="number">#c5603e</span></span><br><span class="line">      --post-body-link-hover-color: <span class="number">#e5724b</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调整归档页面 css 样式</span><br><span class="line">// 隐藏归档页面总文章title</span><br><span class="line"><span class="selector-class">.posts-collapse</span> <span class="selector-class">.post-content</span> <span class="selector-class">.collection-title</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 竖线是这个 before 元素控制的，改细，同时稍微一动位置与标题栏前的圆心对齐</span><br><span class="line">// 左侧的竖线原来太抢眼了，这里弱化竖线的视觉效果</span><br><span class="line"><span class="selector-class">.posts-collapse</span> <span class="selector-class">.post-content</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--archive-post-content-before-color)</span><br><span class="line">  margin-left: -<span class="number">0.5px</span></span><br><span class="line">  top: <span class="number">1em</span></span><br><span class="line">  width: <span class="number">1px</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.posts-collapse</span> <span class="selector-class">.post-content</span> <span class="selector-class">.collection-year</span> <span class="selector-class">.collection-year-count</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 年份缩进，看起来就更有层次感</span><br><span class="line"><span class="selector-class">.posts-collapse</span> <span class="selector-class">.post-content</span> <span class="selector-class">.collection-year</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">40px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 去掉掉年份前的圆点</span><br><span class="line"><span class="selector-class">.posts-collapse</span> <span class="selector-class">.post-content</span> <span class="selector-class">.collection-year</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调整归档页面的上的间距</span><br><span class="line"><span class="selector-class">.posts-collapse</span> <span class="selector-class">.post-content</span> <span class="selector-class">.collection-header</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 文档标题字体整体放大，强调一下视觉效果</span><br><span class="line"><span class="selector-class">.posts-collapse</span> <span class="selector-class">.post-content</span> <span class="selector-class">.post-header</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.1em</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 文档标题前的日期字体方法，原来其实是个缩小效果，这么写之后就取消了缩小效果</span><br><span class="line"><span class="selector-class">.posts-collapse</span> <span class="selector-class">.post-content</span> <span class="selector-class">.post-meta-container</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: inherit; <span class="comment">/* or use initial or unset */</span></span><br><span class="line">&#125;</span><br><span class="line">// 减小页面最上方的空隙</span><br><span class="line"><span class="selector-class">.archive</span> <span class="selector-class">.post-block</span><span class="selector-pseudo">:first</span>-of-type &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 归档页 title 添加选中的加粗放大效果和动画</span><br><span class="line"><span class="selector-class">.posts-collapse</span> <span class="selector-class">.post-content</span> <span class="selector-class">.post-title</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: font-size <span class="number">0.1s</span> ease, font-weight <span class="number">0.1s</span> ease; <span class="comment">/* 添加过渡动画 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.posts-collapse</span> <span class="selector-class">.post-content</span> <span class="selector-class">.post-title</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.1em</span>; <span class="comment">/* 放大字体大小，1.1em 表示放大 10% */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 首页 post 间距调整</span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-block</span><span class="selector-pseudo">:first</span>-of-type &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-block</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:first</span>-of-type) &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 分页  </span><br><span class="line"><span class="selector-class">.pagination</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">60px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.pagination</span> <span class="selector-class">.prev</span>, <span class="selector-class">.pagination</span> <span class="selector-class">.next</span>, <span class="selector-class">.pagination</span> <span class="selector-class">.page-number</span>, <span class="selector-class">.pagination</span> <span class="selector-class">.space</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: -<span class="number">1px</span> <span class="number">10px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 减小 tag 页面最上方的空隙</span><br><span class="line"><span class="selector-class">.tag</span> <span class="selector-class">.post-block</span><span class="selector-pseudo">:first</span>-of-type &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 减小 category 页面最上方的空隙</span><br><span class="line"><span class="selector-class">.category</span> <span class="selector-class">.post-block</span><span class="selector-pseudo">:first</span>-of-type &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改正文中的超链接颜色,但不修改阅读原文的链接颜色</span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">a</span><span class="selector-pseudo">:not</span>(<span class="selector-class">.btn</span>) &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--post-body-link-color) //超链接显示颜色</span><br><span class="line">  border-bottom-color: <span class="built_in">var</span>(--post-body-link-color)</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">var</span>(--post-body-link-hover-color);  //鼠标移动上去后超链接颜色</span><br><span class="line">    <span class="attribute">border-bottom-color</span>: <span class="built_in">var</span>(--post-body-link-hover-color)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>使用脚本查看 macOS 电池信息</title>
    <url>/2017/mac-battery/</url>
    <content><![CDATA[<h2 id="shell-命令获取电池信息"><a href="#shell-命令获取电池信息" class="headerlink" title="shell 命令获取电池信息"></a>shell 命令获取电池信息</h2><p>刚开始使用 macbook pro 后总是查看电池的信息，担心电池衰减快导致续航崩掉 orz，毕竟 macbook 的一个卖点就是续航。后来每次都要打开 system info 切换到 battery 查看，有点麻烦，就产生了一个想法写一个脚本每天自动记录 battery 的最大容量，隔一段时间使用图表画出容量的变化。</p>
<p>经过一番 google 后，一开始是发现了有 python 的库 <code>psutil</code> 和 <code>power</code> 可以访问系统的信息，但是似乎都得不到想要的电池最大容量这个数据，最后在<a href="https://apple.stackexchange.com/questions/116429/using-bash-terminal-to-get-number-of-battery-recharge-cycles">这个网站</a>发现了有用的 bash 命令。</p>
<span id="more"></span>
<p>笔记本以树形的方式记录了 IO 设备的信息，使用 <code>ioreg</code> 可以查看这些信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ioreg -l -w0 | grep Capacity</span><br><span class="line"></span><br><span class="line">//output</span><br><span class="line">    | |           &quot;MaxCapacity&quot; = 6108</span><br><span class="line">    | |           &quot;CurrentCapacity&quot; = 3288</span><br><span class="line">    | |           &quot;LegacyBatteryInfo&quot; = &#123;&quot;Amperage&quot;=18446744073709550947,&quot;Flags&quot;=4,&quot;Capacity&quot;=6108,&quot;Current&quot;=3288,&quot;Voltage&quot;=11363,&quot;Cycle Count&quot;=38&#125;</span><br><span class="line">    | |           &quot;DesignCapacity&quot; = 6559</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">system_profiler SPPowerDataType | grep &quot;Cycle Count&quot; | awk &#x27;&#123;print $3&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>这个命令拿到的是循环次数，稍加改造就可以拿到最大电池容量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">system_profiler SPPowerDataType | grep &quot;Full Charge Capacity&quot; | awk &#x27;&#123;print $5&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>同时 google 下 <code>system_profiler</code> 这个命令，发现这是 macOS 提供的系统信息查询的命令</p>
<blockquote>
<p> system_profiler reports on the hardware and software configuration of the system.  It can generate plain text reports or XML reports which can be opened with System Information.app</p>
</blockquote>
<p>使用该命令就如同查看 system info，只不过是同图形界面变到了 terminal 上</p>
<p>既然可以通过这个命令拿到想要的信息，下一步就是如何使用 python 调用这些命令并编写脚本了。</p>
<h2 id="编写-python-脚本"><a href="#编写-python-脚本" class="headerlink" title="编写 python 脚本"></a>编写 python 脚本</h2><p><a href="https://github.com/AkisAya/batteryinfo">获取 python 脚本</a></p>
<p>使用 <code>os.popen()</code> 调用 shell 命令并输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">comm = <span class="string">&quot;system_profiler SPPowerDataType | grep &#x27;Full Charge Capacity&#x27; | awk &#x27;&#123;print $5&#125;&#x27;&quot;</span></span><br><span class="line">os.popen(comm).read().strip()</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="string">&#x27;6075&#x27;</span></span><br></pre></td></tr></table></figure>

<p>为了提取更多有用的信息，可以保存 <code>system_profiler SPPowerDataType</code> 输出的信息，然后使用正则表达式提取我们需要的信息。创建一个类来完成这个任务再好不过了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Battery</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.power_info = os.popen(<span class="string">&quot;system_profiler SPPowerDataType&quot;</span>).read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get_number_value</span>(<span class="params">self, pattern</span>):</span><br><span class="line">        ret = re.search(pattern, self.power_info).group(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(ret)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get_string_value</span>(<span class="params">self, pattern</span>):</span><br><span class="line">        <span class="keyword">return</span> re.search(pattern, self.power_info).group().split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>].strip()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">max_capacity</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__get_number_value(<span class="string">r&#x27;Full Charge Capacity.*?(\d+)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">current_capacity</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__get_number_value(<span class="string">r&#x27;Charge Remaining.*?(\d+)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cycle_count</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__get_number_value(<span class="string">r&#x27;Cycle Count.*?(\d+)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">design_capacity</span>(<span class="params">self</span>):</span><br><span class="line">        info = os.popen(<span class="string">&#x27;ioreg -l -w0 | grep DesignCapacity&#x27;</span>).read()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(info.split(<span class="string">&quot;=&quot;</span>)[<span class="number">1</span>].strip())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">percentage</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(self.current_capacity()/self.max_capacity() * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">battery_health</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(self.max_capacity() / self.design_capacity() * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">battery_condition</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__get_string_value(<span class="string">r&#x27;Condition.*&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_charging</span>(<span class="params">self</span>):</span><br><span class="line">        status = self.__get_string_value(<span class="string">r&#x27;Charging.*&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> status == <span class="string">&#x27;No&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>由于 <code>system_profiler SPPowerDataType</code> 输出的信息本身就是格式化的，所以要进一步优化这个方案的话可以直接解析输出信息构造出一个树，使用 json 格式来存放信息或者使用 dict 来存放信息</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在使用 python 的 re 模块时发现，在匹配字符串的时候最多只会匹配到一行的末尾。比如：</p>
<p>对于字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Charge Remaining (mAh): 5268</span><br><span class="line">Fully Charged: No</span><br><span class="line">Charging: No</span><br><span class="line">Full Charge Capacity (mAh): 6097</span><br></pre></td></tr></table></figure>

<p>当我们使用 <code>re.search(r&#39;Charging.*&#39;)</code> 时，会匹配到 <code>Charging: No</code> 这一行，但是也不会跨行</p>
<h2 id="macOS-定时任务"><a href="#macOS-定时任务" class="headerlink" title="macOS 定时任务"></a>macOS 定时任务</h2><p>前面已经写了基本的类获取电池信息，现在就写个定时任务每天执行任务记录电池信息，数据够多后画出来看看电池的变化吧。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># output_battery_info.py</span></span><br><span class="line"><span class="keyword">from</span> battery_info <span class="keyword">import</span> Battery</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">batt = Battery()</span><br><span class="line">path = <span class="string">&#x27;/Users/akis/Documents/battery/info.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    logtime = datetime.datetime.now().strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line">    line = <span class="string">&#x27;&#123;0&#125;\t&#123;1&#125;\t&#123;2&#125;\n&#x27;</span>.<span class="built_in">format</span>(logtime, batt.max_capacity(), batt.cycle_count())</span><br><span class="line">    file.write(line)</span><br></pre></td></tr></table></figure>

<p>剩下的就是使用 mac 的 launchctl 定时执行脚本了</p>
<p>launchctl 的使用参见 <a href="http://blog.csdn.net/u012390519/article/details/74542042">Mac执行定时任务之Launchctl</a></p>
<p>定义一个可执行文件 <code>logBatteryInfo.sh</code> 如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">/usr/local/bin/python3 /Users/akis/codespace/python/batteryinfo/output_battery_info.py</span><br></pre></td></tr></table></figure>

<p>自定义任务列表 <code>me.battery.launchctl.plist</code> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">  &lt;dict&gt;</span><br><span class="line">    &lt;key&gt;Label&lt;/key&gt;</span><br><span class="line">    &lt;string&gt;me.battery.launchctl.plist&lt;/string&gt;</span><br><span class="line">    &lt;key&gt;ProgramArguments&lt;/key&gt;</span><br><span class="line">    &lt;array&gt;</span><br><span class="line">      &lt;string&gt;/Users/akis/Documents/battery/logBatteryInfo.sh&lt;/string&gt;</span><br><span class="line">    &lt;/array&gt;</span><br><span class="line">    &lt;key&gt;StartCalendarInterval&lt;/key&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">          &lt;key&gt;Minute&lt;/key&gt;</span><br><span class="line">          &lt;integer&gt;20&lt;/integer&gt;</span><br><span class="line">          &lt;key&gt;Hour&lt;/key&gt;</span><br><span class="line">          &lt;integer&gt;23&lt;/integer&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br><span class="line">    &lt;key&gt;StandardOutPath&lt;/key&gt;</span><br><span class="line">      &lt;string&gt;/Users/akis/Documents/battery/logBatteryInfo.log&lt;/string&gt;</span><br><span class="line">    &lt;key&gt;StandardErrorPath&lt;/key&gt;</span><br><span class="line">    &lt;string&gt;/Users/akis/Documents/battery/logBatteryInfo.err&lt;/string&gt;</span><br><span class="line">  &lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 springboot actuator &amp; prometheus &amp; grafana 监控你的应用</title>
    <url>/2020/%E4%BD%BF%E7%94%A8-springboot-actuator-prometheus-grafana-%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>线上的项目经常需要对一些指标如请求量，qps，延时等指标做统计方便我们观察系统的运行状态，并帮助我们定位系统可能存在的性能等问题。springboot actuator 为 springboot 应用提供了指标的统计方法，prometheus 是一个监控中心，grafana 则是一个数据展示中心，本文将通过一个小案例介绍综合使用 springboot actuator、prometheus、grafana 监控我们的应用。</p>
<span id="more"></span>
<h2 id="springboot-actuator"><a href="#springboot-actuator" class="headerlink" title="springboot actuator"></a>springboot actuator</h2><h3 id="引入-springboot-actuator"><a href="#引入-springboot-actuator" class="headerlink" title="引入 springboot actuator"></a>引入 springboot actuator</h3><p>引入 actuator 依赖即可开始使用 springboot actuator 为我们提供的各种监控指标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>默认情况下 actuator 提供了很多的监控端点（EndPoint），路径均为 <code>/actuatro/&lt;endpoint_name&gt;</code>，比如应用健康信息 health, 访问 <code>/actuator/health</code>，可得到如下返回</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UP&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>为了提供能被 prometheus 解析收集的监控信息，我们需要启用 prometheus 端点并添加 prometheus 依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># application.properties</span><br><span class="line">management.endpoints.web.exposure.include=info,health,prometheus</span><br><span class="line"></span><br><span class="line"># pom.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-registry-prometheus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>访问 <code>/actuator/prometheus</code> 得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># HELP process_start_time_seconds Start time of the process since unix epoch.</span><br><span class="line"># TYPE process_start_time_seconds gauge</span><br><span class="line">process_start_time_seconds 1.581927873353E9</span><br><span class="line"># HELP jvm_threads_states_threads The current number of threads having NEW state</span><br><span class="line"># TYPE jvm_threads_states_threads gauge</span><br><span class="line">jvm_threads_states_threads&#123;state=&quot;runnable&quot;,&#125; 9.0</span><br><span class="line">jvm_threads_states_threads&#123;state=&quot;blocked&quot;,&#125; 0.0</span><br><span class="line">jvm_threads_states_threads&#123;state=&quot;waiting&quot;,&#125; 13.0</span><br><span class="line">jvm_threads_states_threads&#123;state=&quot;timed-waiting&quot;,&#125; 2.0</span><br><span class="line">jvm_threads_states_threads&#123;state=&quot;new&quot;,&#125; 0.0</span><br><span class="line">jvm_threads_states_threads&#123;state=&quot;terminated&quot;,&#125; 0.0</span><br><span class="line"># HELP process_files_open_files The open file descriptor count</span><br><span class="line"># TYPE process_files_open_files gauge</span><br><span class="line">process_files_open_files 96.0</span><br><span class="line"># HELP system_load_average_1m The sum of the number of runnable entities queued to available processors and the number of runnable entities running on the available processors averaged over a period of time</span><br><span class="line"># TYPE system_load_average_1m gauge</span><br><span class="line">system_load_average_1m 1.30322265625</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到这些数据是符合 prometheus 定义的数据收集的格式的，默认提供了 jvm, cpu 和 web 等方面的指标<br>我们给 web 应用定义了 <code>/index</code>,<code>/recommend</code> 的接口，访问一下这些接口后再看看 <code>/actuator/prometheus</code>的输出结果，发现多了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># HELP http_server_requests_seconds  </span><br><span class="line"># TYPE http_server_requests_seconds summary</span><br><span class="line">http_server_requests_seconds_count&#123;exception=&quot;None&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;/index&quot;,&#125; 1.0</span><br><span class="line">http_server_requests_seconds_sum&#123;exception=&quot;None&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;/index&quot;,&#125; 0.013830247</span><br><span class="line">http_server_requests_seconds_count&#123;exception=&quot;None&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;/actuator/prometheus&quot;,&#125; 3.0</span><br><span class="line">http_server_requests_seconds_sum&#123;exception=&quot;None&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;/actuator/prometheus&quot;,&#125; 0.071013869</span><br><span class="line">http_server_requests_seconds_count&#123;exception=&quot;None&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;/recommend&quot;,&#125; 1.0</span><br><span class="line">http_server_requests_seconds_sum&#123;exception=&quot;None&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;/recommend&quot;,&#125; 0.092041806</span><br><span class="line"># HELP http_server_requests_seconds_max  </span><br><span class="line"># TYPE http_server_requests_seconds_max gauge</span><br><span class="line">http_server_requests_seconds_max&#123;exception=&quot;None&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;/index&quot;,&#125; 0.013830247</span><br><span class="line">http_server_requests_seconds_max&#123;exception=&quot;None&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;/actuator/prometheus&quot;,&#125; 0.056484717</span><br><span class="line">http_server_requests_seconds_max&#123;exception=&quot;None&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;/recommend&quot;,&#125; 0.092041806</span><br></pre></td></tr></table></figure>
<p>可以看到这些是我们访问这些接口的请求数量和请求时间的相关统计，这些指标是 springboot actuator 默认为我们提供的监控指标，但是有时候我们除了想知道一个接口的总耗时外，也想知道一个接口中各个方法的耗时，又该怎么统计呢？这时候可以使用 Micrometer 在我们的应用中开发相应的统计代码</p>
<h3 id="Micrometer"><a href="#Micrometer" class="headerlink" title="Micrometer"></a>Micrometer</h3><p>Micormeter 为应用的监控提供统一的接口，类似于 slif4，下面以 timer 指标为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private MeterRegistry registry;</span><br><span class="line"></span><br><span class="line">public String recommend() throws InterruptedException &#123;</span><br><span class="line">    Timer.Sample sample;</span><br><span class="line"></span><br><span class="line">    sample = Timer.start(registry);</span><br><span class="line">    recall();</span><br><span class="line">    sample.stop(registry.timer(&quot;recommend.timer.recall&quot;));</span><br><span class="line"></span><br><span class="line">    sample = Timer.start(registry);</span><br><span class="line">    profile();</span><br><span class="line">    sample.stop(registry.timer(&quot;recommend.timer.profile&quot;));</span><br><span class="line"></span><br><span class="line">    sample = Timer.start(registry);</span><br><span class="line">    predict();</span><br><span class="line">    sample.stop(registry.timer(&quot;recommend.timer.predict&quot;));</span><br><span class="line"></span><br><span class="line">    return &quot;OK&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用 Timer 统计了各个方法的耗时，并为每个方法的耗时定义了一个诸如 <code>recommend.timer.recall</code> 的名字</p>
<p>再次访问 <code>/actuator/prometheus</code> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># HELP recommend_timer_recall_seconds_max  </span><br><span class="line"># TYPE recommend_timer_recall_seconds_max gauge</span><br><span class="line">recommend_timer_recall_seconds_max 0.0</span><br><span class="line"># HELP recommend_timer_recall_seconds  </span><br><span class="line"># TYPE recommend_timer_recall_seconds summary</span><br><span class="line">recommend_timer_recall_seconds_count 2.0</span><br><span class="line">recommend_timer_recall_seconds_sum 0.05997796</span><br></pre></td></tr></table></figure>
<p>可以看到统计结果中多出了我们对方法耗时的统计指标</p>
<h3 id="单指标属性"><a href="#单指标属性" class="headerlink" title="单指标属性"></a>单指标属性</h3><p>有时候我们并不满足于知道一个请求的总时间或者一个方法执行的总时间，比如我们想知道这个请求的平均执行时间，TP99的执行时间。这时候我们就可以定义<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#per-meter-properties">单指标属性</a>，如使用 <code>management.metrics.distribution.percentiles-histogram</code> 可以统计出指标的分为图数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># application.properties</span><br><span class="line"></span><br><span class="line">management.metrics.distribution.percentiles-histogram.http.server.requests=true</span><br><span class="line">management.metrics.distribution.percentiles-histogram.recommend.timer.recall=true</span><br><span class="line">management.metrics.distribution.percentiles-histogram.recommend.timer.profile=true</span><br><span class="line">management.metrics.distribution.percentiles-histogram.recommend.timer.predict=true</span><br></pre></td></tr></table></figure>
<p><code>http.server.requests</code> 是 springboot actuator 自动为我们监控的属性，参考<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready-metrics-spring-mvc">Spring MVC Metrics</a>，后面的 <code>recommend.timer.recall</code> 等是我们在程序中定义的指标，再次访问接口后的统计数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># HELP recommend_timer_predict_seconds  </span><br><span class="line"># TYPE recommend_timer_predict_seconds histogram</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.001&quot;,&#125; 0.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.001048576&quot;,&#125; 0.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.001398101&quot;,&#125; 0.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.001747626&quot;,&#125; 0.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.002097151&quot;,&#125; 0.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.002446676&quot;,&#125; 0.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.002796201&quot;,&#125; 0.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.003145726&quot;,&#125; 0.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.003495251&quot;,&#125; 0.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.003844776&quot;,&#125; 0.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.004194304&quot;,&#125; 0.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.005592405&quot;,&#125; 0.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.006990506&quot;,&#125; 0.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.008388607&quot;,&#125; 0.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.009786708&quot;,&#125; 0.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.011184809&quot;,&#125; 0.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.01258291&quot;,&#125; 0.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.013981011&quot;,&#125; 0.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.015379112&quot;,&#125; 0.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.016777216&quot;,&#125; 0.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.022369621&quot;,&#125; 0.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.027962026&quot;,&#125; 0.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.033554431&quot;,&#125; 5.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.039146836&quot;,&#125; 5.0</span><br><span class="line">recommend_timer_predict_seconds_bucket&#123;le=&quot;0.044739241&quot;,&#125; 5.0</span><br></pre></td></tr></table></figure>
<p>可以看到了多出了这些 bucket 相关的统计信息，基于这些统计信息我们就能得到更详细的耗时统计</p>
<h2 id="prometheus"><a href="#prometheus" class="headerlink" title="prometheus"></a>prometheus</h2><p>关于 promethus 的详细介绍可以参考<a href="https://prometheus.io/docs/prometheus/latest/getting_started/">官网文档</a>或者优质的<a href="https://yunlzheng.gitbook.io/prometheus-book/">第三方文档</a>，这里我们直接说如何使用</p>
<h3 id="使用-docker-安装"><a href="#使用-docker-安装" class="headerlink" title="使用 docker 安装"></a>使用 docker 安装</h3><p>定义 <code>prometheus.yml</code> 如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># my global config</span><br><span class="line">global:</span><br><span class="line">  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.</span><br><span class="line">  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.</span><br><span class="line">  # scrape_timeout is set to the global default (10s).</span><br><span class="line"></span><br><span class="line"># Load rules once and periodically evaluate them according to the global &#x27;evaluation_interval&#x27;.</span><br><span class="line">rule_files:</span><br><span class="line"># - &quot;first_rules.yml&quot;</span><br><span class="line"># - &quot;second_rules.yml&quot;</span><br><span class="line"></span><br><span class="line"># A scrape configuration containing exactly one endpoint to scrape:</span><br><span class="line"># Here it&#x27;s Prometheus itself.</span><br><span class="line">scrape_configs:</span><br><span class="line">  # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span><br><span class="line">  - job_name: &#x27;prometheus&#x27;</span><br><span class="line"></span><br><span class="line">    # metrics_path defaults to &#x27;/metrics&#x27;</span><br><span class="line">    # scheme defaults to &#x27;http&#x27;.</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&#x27;localhost:9090&#x27;]</span><br><span class="line"></span><br><span class="line">  - job_name: &#x27;actuator-demo&#x27;</span><br><span class="line">    metrics_path: &#x27;/actuator/prometheus&#x27;</span><br><span class="line">    scrape_interval: 5s</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&#x27;192.168.0.4:8080&#x27;]</span><br></pre></td></tr></table></figure>
<p>由于我们用 docker 方式启动 prometheus，因此 target 中的 ip 填写本机的 ip 地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 9090:9090 -v path_to_prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus</span><br></pre></td></tr></table></figure>
<p>访问 localhost:9090 即可打开 prometheus 的 web 页面，并且能看到我们之前在程序中自定义的指标<br><img src="/2020/%E4%BD%BF%E7%94%A8-springboot-actuator-prometheus-grafana-%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8/prometheus.png" alt="prometheus"><br><img src="/2020/%E4%BD%BF%E7%94%A8-springboot-actuator-prometheus-grafana-%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8/metrics.png" alt="metrics"></p>
<h2 id="grafana"><a href="#grafana" class="headerlink" title="grafana"></a>grafana</h2><p>grafana 可以对接多种数据源并且在一个 dashboard 中添加多个 panel 展示不同的数据，我们使用 docker 安装 grafana</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --name=grafana -p 3000:3000 grafana/grafana</span><br></pre></td></tr></table></figure>
<p>然后登录 localhost:3000，默认的用户名和密码是 admin&#x2F;admin，我们添加刚才的 prometheus 为数据源<br><img src="/2020/%E4%BD%BF%E7%94%A8-springboot-actuator-prometheus-grafana-%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8/datasource.png" alt="datasource"><br>然后添加一个 query<br><img src="/2020/%E4%BD%BF%E7%94%A8-springboot-actuator-prometheus-grafana-%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8/query.png" alt="query"></p>
<p>使用 promQL 我们可以统计更多的指标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 统计访问 /recommend 的 qps</span><br><span class="line">irate(http_server_requests_seconds_count&#123;uri=&#x27;/recommend&#x27;&#125;[1m])</span><br><span class="line"></span><br><span class="line"># 统计平均时间</span><br><span class="line">rate(http_server_requests_seconds_sum&#123;uri=&quot;/recommend&quot;&#125;[1m])/rate(http_server_requests_seconds_count&#123;uri=&quot;/recommend&quot;&#125;[1m])</span><br><span class="line"></span><br><span class="line"># 计算最大时间</span><br><span class="line">http_server_requests_seconds_max&#123;uri=&quot;/recommend&quot;&#125;</span><br><span class="line"></span><br><span class="line">## 计算TP95</span><br><span class="line">histogram_quantile(0.95, http_server_requests_seconds_bucket&#123;uri=&#x27;/recommend&#x27;&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/%E4%BD%BF%E7%94%A8-springboot-actuator-prometheus-grafana-%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8/whole.png" alt="whole"></p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>prometheus</tag>
        <tag>grafana</tag>
        <tag>micrometer</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Travis CI 自动化部署 hexo 博客的碎碎念</title>
    <url>/2018/%E4%BD%BF%E7%94%A8Travis-CI-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2-hexo-%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>偶然点进去同事的博客，看到了使用 Travis CI 自动化部署 hexo 博客的文章，突然有点手痒了。从电脑角落里翻出来以前 hexo 的博客，发现只有寥寥两篇，而且最近的一篇还是过年的时候，这时候真觉得自己又开始部署 hexo 只是为了打发时间，某天又想起这个博客的时候最新的怕还是这篇自动化部署的碎碎念。不过，生命在于折腾，这便开始吧。</p>
<span id="more"></span>

<h2 id="什么是-Travis-CI"><a href="#什么是-Travis-CI" class="headerlink" title="什么是 Travis CI"></a>什么是 Travis CI</h2><p>CI 即持续集成（Continuous Integration），CI 主要是针对开发中的频繁迭代的代码更新，做自动化的构建和测试工作，及时发现代码中的bug，<a href="https://travis-ci.org/">Travis CI</a> 就是提供这种持续集成能力的服务。</p>
<p>Travis CI 跟 Github 是绑定在一起的，使用 github 账号登录 Travis CI 后能看到 repos，勾选相应的 repo 后，它能够自动检测 其中某个分支上的 commit，然后拉取仓库中的代码, 基于 <code>.travis.yml</code> 中的配置运行定制化的命令。因为我们的 hexo 博客就是在根目录下运行 <code>hexo g -d</code>，然后将编译完成的静态文件 push 到 github master 分支，所以我们自然可以通过将 hexo 博客的源码保存在 github 分支上，让 Travis CI 监测这个分支，每当有 commit 的时候，就自动拉取该分支然后编译<br><img src="/2018/%E4%BD%BF%E7%94%A8Travis-CI-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2-hexo-%E5%8D%9A%E5%AE%A2/travis_dashboard.png"></p>
<h2 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h2><p>Travis CI 官网本身提供了一个部署文件到 github pages 的<a href="https://docs.travis-ci.com/user/deployment/pages/">最小化配置</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  provider: pages</span><br><span class="line">  skip-cleanup: true</span><br><span class="line">  github-token: $GITHUB_TOKEN  # Set in the settings page of your repository, as a secure variable</span><br><span class="line">  keep-history: true</span><br><span class="line">  on:</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>
<p>我们只有基于这个配置添加 hexo 相关的必要步骤就行</p>
<p><code>github-token</code> 的作用是为了让我们有权限将编译后的静态文件有权限推回 github，我们需要在 github 的 <a href="https://github.com/settings/tokens">personal access token</a> 里设置，该 token 权限应该尽量小，对于我们自动自动化部署博客这个场景来说，只需要勾选 public_repo 就行了。<br><img src="/2018/%E4%BD%BF%E7%94%A8Travis-CI-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2-hexo-%E5%8D%9A%E5%AE%A2/repo_token.png"><br>复制后生成的 token，在设置面板里添加环境变量<br><img src="/2018/%E4%BD%BF%E7%94%A8Travis-CI-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2-hexo-%E5%8D%9A%E5%AE%A2/env.png"></p>
<p>启用 Travis CI 这一部我们就做好了，剩下就是配置好 <code>.travis.yml</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">language: node_js #指定环境为 Node.js</span><br><span class="line"></span><br><span class="line">node_js:</span><br><span class="line">- &quot;6.0.0&quot;</span><br><span class="line"></span><br><span class="line">before_install:</span><br><span class="line">- export TZ=&#x27;Asia/Shanghai&#x27; #设置时区 非必须</span><br><span class="line"></span><br><span class="line">script:</span><br><span class="line">- hexo generate #生成博客</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  provider: pages</span><br><span class="line">  skip_cleanup: true</span><br><span class="line">  github_token: $GITHUB_TOKEN</span><br><span class="line">  local_dir: public</span><br><span class="line">  repo: AkisAya/akisaya.github.io</span><br><span class="line">  target_branch: master</span><br><span class="line">  on:</span><br><span class="line">    branch: source</span><br></pre></td></tr></table></figure>
<p>配置文件也很简单，<code>branch: source</code> 指的是监控 repo 上的 source 分支，我们的博客源码就是保存在该分支上，<code>local_dir</code> 指的是要推送的文件夹，hexo 编译完成后生成的静态文件就是在 <code>public</code> 文件夹里，<code>repo</code> 就是推送的 github repo，默认是当前 repo，命名规则是 <code>username/repo-name</code>, <code>target_branch</code> 是我们要推送到的分支。将这个配置文件放在 博客源码目录，一起推送到 github 上就行了。</p>
<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>推送源码到 github 的 source 分支上意味着我们的根目录就是 git 的 repo，但是同时，themes 下的主题也是一个 git 的 repo，所以两者之间是构成了 submodule 的关系，如果 root repo 没有添加这个 submodule 的话，push 的时候没有把 themes 下的文件也 push 上去，结果造成 Travis 构建的时候没有样式模板生成静态文件。</p>
<p>用 <code>git submodule add https://github.com/AkisAya/hexo-theme-next.git themes/next</code> 添加了 submodule 再推送，发现在 github 里 source 分支下的 themes&#x2F;next 实质上是一个超链接，链到刚才指定的仓库，这个时候 travis 构建的时候就会分别从我们的 source 分支和主题对应的分支拉取代码。但是这个时时候回出现什么问题呢，由于本地主题我们其实是有修改的，可能导致 source 分支上的 主题分支的 commit id 与 主题仓库的 commit id 不一致，然后 travis 拉取主题代码的时候就会失败。后来我直接把主题的源仓库 fork 了一份，添加 submodule 的时候关联到我 fork 的这个仓库，使 submodule 的 commit id 与 源仓库的 commit id 保持一致算是暂时解决了这个问题。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>折腾完了，最后我也不想搞 Travis CI 自动部署了。其实最后会发现，Travis CI 并没有减少什么部署步骤。<br>在本地编译部署你只需要</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new post &quot;xxx.md&quot;</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
<p>使用 Travis CI 的话你需要</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add xxx</span><br><span class="line">git commit -m &quot;xxx&quot;</span><br></pre></td></tr></table></figure>
<p>你看，其实并没有减少什么工作量，反而是如果以后想要更新主题的话，本地拉取更新感觉更方便。也可能是我的使用姿势不对吧。<br>不过，博客源码倒是在 github 保存了一份，不用担心丢失，或者有多台电脑写博客的需求的话，checkout 分支然后 commit 确实方便很多了</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>travis</tag>
      </tags>
  </entry>
  <entry>
    <title>将你的应用部署在 K8S 上</title>
    <url>/2020/%E5%B0%86%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E5%9C%A8-K8S-%E4%B8%8A/</url>
    <content><![CDATA[<p>Kubernetes（简称 K8S）自发布以来，已经成为容器化编排的最佳工具，本文通过一个简单的案例聊一聊如何将一个容器部署到 k8s 集群上，文中所需的代码和容器均在 <a href="https://github.com/AkisAya/simple-web-for-k8s-demo">GITHUB</a> 上。如需要搭建一个 k8s 集群，可以通过 <a href="https://github.com/kubernetes/minikube">minikube</a> 来搭建，也可以使用 docker for desktop 自带的 k8s 集群</p>
<span id="more"></span>
<h2 id="1-创建一个最简单的-Deployment"><a href="#1-创建一个最简单的-Deployment" class="headerlink" title="1 创建一个最简单的 Deployment"></a>1 创建一个最简单的 Deployment</h2><p>先简单介绍几个概念</p>
<ul>
<li>Pod: k8s 最核心的一个概念，是一个或多个 container 的集合。一个 pod 中的 container 共享存储和网络，k8s 支持多种 contianer，但是目前 docker container 是最常见的一种。我们的应用最终都是各个 pod 的形式存在的，pod 也是 k8s 进行调度的最小单位。<br><img src="/2020/%E5%B0%86%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E5%9C%A8-K8S-%E4%B8%8A/pod.png" alt="pod"></li>
<li>ReplicaSet: 也是 k8s 中的一种资源，管理一个 pod 的多个副本。一般我们部署 pod 为了保证高可用，都会部署多个副本，避免单点故障。如果 replicaSet 管理的某个 pod 挂掉了，它会请求一个新的 pod 出来以满足设定的副本数量。k8s 还有一个 ReplicaionController 也是控制 pod 副本的，但是相比 ReplicaionController，ReplicaSet 对 pod 标签的支持会更好，现在一般就用 ReplicaSet<br><img src="/2020/%E5%B0%86%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E5%9C%A8-K8S-%E4%B8%8A/replica.png" alt="replica"></li>
<li>Deployment: 是一个更 high-level 的资源，创建一个 Deployment 后会创建一个 ReplicaSet，然后 ReplicaSet 会创建预期数量的 pod。deployment 可以对 ReplicaSet 的版本进行管理，方便回滚。在生产上一般都是创建一个 Deployment<br><img src="/2020/%E5%B0%86%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E5%9C%A8-K8S-%E4%B8%8A/deployment.png" alt="depolyment"></li>
</ul>
<p>我们先准备一个简单的 web 应用 simple-web，并将其打包成 docker 镜像 simple-web:1.0。web 应用后，访问 <code>/index</code>，将会输出 web 应用的名字，访问 <code>/health</code>，会返回 “OK”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">curl http://ip:8080/index</span></span><br><span class="line">  web site name is [demo-web]</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">curl http://ip:8080/health</span></span><br><span class="line">  OK</span><br></pre></td></tr></table></figure>

<p>定义一个 <code>deployment.yml</code> 如下<br><img src="/2020/%E5%B0%86%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E5%9C%A8-K8S-%E4%B8%8A/deploy-config.png" alt="config"><br>使用 <code>kubectl create -f deployment.yml</code>，然后 get 资源可以发现我们创建了一个 deployment，一个 replicaset，一个 pod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ k get deploy</span><br><span class="line">NAME         READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">simple-web   1/1     1            1           2d4h</span><br><span class="line">➜  ~ k get rs</span><br><span class="line">NAME                    DESIRED   CURRENT   READY   AGE</span><br><span class="line">simple-web-6bdf7b4d84   1         1         1       47h</span><br><span class="line">➜  ~ k get pods</span><br><span class="line">NAME                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">simple-web-6bdf7b4d84-p7jkp   1/1     Running   0          47h</span><br></pre></td></tr></table></figure>
<p>我们可以进入到 pod 中执行 curl 命令查看输出，也可以把 curl 命令传递给 kubectl exec</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ k exec  simple-web-6bdf7b4d84-p7jkp --  curl -s http://localhost:8080/index</span><br><span class="line">web site name is [demo-web]</span><br></pre></td></tr></table></figure>

<h2 id="2-使用-service-访问-pod"><a href="#2-使用-service-访问-pod" class="headerlink" title="2 使用 service 访问 pod"></a>2 使用 service 访问 pod</h2><h3 id="2-1-port-forward"><a href="#2-1-port-forward" class="headerlink" title="2.1 port-forward"></a>2.1 port-forward</h3><p>仅仅是创建一个 Deployment，我们还只能在 pod 内访问自己的 web 服务，而无法在外部或者 pod 之间访问 web 服务。<code>kubectl port-forward &lt;podname&gt; &lt;hostPort:containerPort&gt;</code> 可以将宿主机的一个 port 代理到容器的一个 pod 上，使我们在宿主机上访问 web 服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ k port-forward simple-web-6bdf7b4d84-p7jkp 8889:8080</span><br><span class="line">Forwarding from 127.0.0.1:8889 -&gt; 8080</span><br><span class="line">Forwarding from [::1]:8889 -&gt; 8080</span><br><span class="line"></span><br><span class="line">➜  ~ curl 127.0.0.1:8889/index</span><br><span class="line">web site name is [demo-web]</span><br></pre></td></tr></table></figure>
<h3 id="2-2-service"><a href="#2-2-service" class="headerlink" title="2.2 service"></a>2.2 service</h3><p>但是当我们有多个副本的 pod 时，我们不可能一个一个 pod 的代理指定端口，同时 port-forward 也没解决 pod 之间的服务发现。这个时候我们需要 <code>Service</code> 来提供路由<br><img src="/2020/%E5%B0%86%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E5%9C%A8-K8S-%E4%B8%8A/service.png" alt="service"><br>我们同样使用 &#96;&#96;kubectl create<code>创建一个</code>Service&#96;</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">simple-web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">simple-web</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>
<p>这里 selector 我们需要填写在 deployment 中定义的 pod 的标签</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ k get svc</span><br><span class="line">NAME                  TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">simple-web            ClusterIP   10.96.156.194   &lt;none&gt;        80/TCP         2d4h</span><br></pre></td></tr></table></figure>
<p>我们创建了一个叫 <code>simple-web</code> 的 service，可以看到 k8s 分配了一个 clusterIP，并将这个 ip 的 80 端口映射到 pod 的 8080 端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ curl 10.96.156.194/index</span><br><span class="line">web site name is [demo-web]</span><br></pre></td></tr></table></figure>
<p>除了用 ip 访问，我们也可以用 serivce 来访问</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ k exec simple-web-6bdf7b4d84-2kzxx -- curl http://simple-web/index</span><br><span class="line">web site name is [demo-web]</span><br></pre></td></tr></table></figure>
<h3 id="2-3-nodeport"><a href="#2-3-nodeport" class="headerlink" title="2.3 nodeport"></a>2.3 nodeport</h3><p>使用 ClusterIP 我们只能在 k8s 集群内访问 pod，如果要从外部访问 pod，则可以定义 NodePort type 的 Service</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">simple-web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">simple-web</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">32100</span></span><br></pre></td></tr></table></figure>
<p>这样我们就可以通过宿主机 ip:nodeport 访问 pod 中的 web 服务了<br>Service 还提供了 LoadBalancer 的 type，方便提供一个 external 的 ip 供访问，一般为云厂商使用，此处不表</p>
<h2 id="3-Volume"><a href="#3-Volume" class="headerlink" title="3 Volume"></a>3 Volume</h2><p>Volume 提供了一种在 pod 的 container 之间数据交互，container 与宿主机或者其它的存储交互的手段。k8s 的 Volume 有很多类型，下面以 EmptyDir 为例看看 Volume 的使用。<br>我们将 web 应用的 log 挂载到 EmptyDir，配置如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">simple-web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">simple-web</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">simple-web</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">simple-web</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">simple-web:1.0</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app-log</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/app/logs</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app-log</span></span><br><span class="line">          <span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在宿主机上找到 emptyDir 的路径，默认是 <code>/var/lib/kubelet/pods/PODUID/volumes/kubernetes.io~empty-dir/VOLUMENAME</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ k get pods simple-web-6bdf7b4d84-2kzxx -o yaml | grep uid</span><br><span class="line">    uid: 437573bc-7398-4004-89ac-0d268e986c74</span><br><span class="line">  uid: be609483-ed6d-427f-b277-81931cc9eb60</span><br></pre></td></tr></table></figure>
<p><code>be609483-ed6d-427f-b277-81931cc9eb60</code> 就是 pod uid<br>以这个 log 为例，我们宿主机上的 log 可以通过 filebeat 收集起来</p>
<h2 id="4-configmap"><a href="#4-configmap" class="headerlink" title="4 configmap"></a>4 configmap</h2><p>当我们把应用部署到 pod 后，如果希望通过更改配置更改应用的行为，肯定不希望是需要重新打包一个镜像，所以我们需要把配置文件分离出来，configmap 就可以帮助我们完成这个事</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">simple-web-config</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">app-config:</span> <span class="string">|-</span></span><br><span class="line">    <span class="string">app.name=web-name-from-config-web</span></span><br></pre></td></tr></table></figure>
<p>然后修改 deployment 如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">simple-web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">simple-web</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">simple-web</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">simple-web</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">simple-web:1.0</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app-log-vol</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/app/logs</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-vol</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/app/conf/application.properties</span></span><br><span class="line">              <span class="attr">subPath:</span> <span class="string">application.properties</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app-log-vol</span></span><br><span class="line">          <span class="attr">emptyDir:</span> &#123;&#125;</span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-vol</span></span><br><span class="line">          <span class="attr">configMap:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">simple-web-config</span></span><br><span class="line">            <span class="attr">items:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app-config</span></span><br><span class="line">                <span class="attr">path:</span> <span class="string">application.properties</span></span><br></pre></td></tr></table></figure>
<p>我们把 configmap 里的配置挂载到了 <code>/app/conf/application.properties</code>，我们应用的启动脚本会读取这个配置文件 <code>java -jar simple-web.jar --spring.config.location=/app/conf/application.properties</code>，通过这种方式，我们就将配置文件与应用分离。修改配置文件后，<code>application.properties</code> 就已经被更新了，但是由于 java 应用不会重新加载配置文件，所以需要重启 pod</p>
<h2 id="5-liveness-readiness-与-pod-resources"><a href="#5-liveness-readiness-与-pod-resources" class="headerlink" title="5 liveness, readiness 与 pod resources"></a>5 liveness, readiness 与 pod resources</h2><h3 id="5-1-liveness-readiness"><a href="#5-1-liveness-readiness" class="headerlink" title="5.1 liveness, readiness"></a>5.1 liveness, readiness</h3><p>k8s 是如何知道一个 pod 无法提供服务了呢？我们需要定义一个健康检查的 liveness ，k8s 会定期请求这个 liveness，判断服务是否健康。<br>readiness 类似，通过 readiness 的定义判读 pod 是否已经可以开始提供服务</p>
<h3 id="5-2-resources"><a href="#5-2-resources" class="headerlink" title="5.2 resources"></a>5.2 resources</h3><p>k8s 提供了限制 container 所能使用的资源量的方法。<code>resources.requests</code> 定义了需要多少资源，用于 k8s 将 pod 调度到资源充足的节点，<code>resources.limits</code> 则限制了 container 可以使用的资源总量。可参考<a href="https://medium.com/expedia-group-tech/kubernetes-container-resource-requirements-part-1-memory-a9fbe02c8a5f">Kubernetes Container Resource Requirements</a></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">simple-web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">simple-web</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">simple-web</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">simple-web</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">simple-web:1.0</span></span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/health</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">          <span class="attr">readinessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/health</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app-log-vol</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/app/logs</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-vol</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/app/conf/application.properties</span></span><br><span class="line">              <span class="attr">subPath:</span> <span class="string">application.properties</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">              <span class="attr">requests:</span></span><br><span class="line">                <span class="attr">memory:</span> <span class="string">2048Mi</span></span><br><span class="line">                <span class="attr">cpu:</span> <span class="number">2</span></span><br><span class="line">              <span class="attr">limits:</span></span><br><span class="line">                <span class="attr">memory:</span> <span class="string">2048Mi</span></span><br><span class="line">                <span class="attr">cpu:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app-log-vol</span></span><br><span class="line">          <span class="attr">emptyDir:</span> &#123;&#125;</span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-vol</span></span><br><span class="line">          <span class="attr">configMap:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">simple-web-config</span></span><br><span class="line">            <span class="attr">items:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app-config</span></span><br><span class="line">                <span class="attr">path:</span> <span class="string">application.properties</span></span><br></pre></td></tr></table></figure>

<h2 id="6-其它待补充，pause-容器等，dashboard"><a href="#6-其它待补充，pause-容器等，dashboard" class="headerlink" title="6 其它待补充，pause 容器等，dashboard"></a>6 其它待补充，pause 容器等，dashboard</h2>]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>深刻理解 Golang Slice</title>
    <url>/2022/%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3-Golang-Slice/</url>
    <content><![CDATA[<blockquote>
<p>Remember, since the slice header is always updated by a call to append, you need to save the returned slice after the call. In fact, the compiler won’t let you call append without saving the result.</p>
</blockquote>
<span id="more"></span>

<p>golang 中数组是指定了长度和类型的一种数据结构，一旦声明其长度便不可更改，因此数组在 golang 中并不实用，用得更多的是 <code>slice</code>，以数组为基础的一种“动态数组”。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">&quot;d&quot;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span></span><br></pre></td></tr></table></figure>
<p>向 slice 里添加数据，必须使用内置关键字 append，并且需要接受返回值。<br>我们知道，在 golang 中，一切都是值传递，也就是向一个函数传递变量，其实是对变量做了一个 copy，因此如 swap 函数如果直接传值而非指针并不能交换入参数的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    t := a</span><br><span class="line">    a = b</span><br><span class="line">    b = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们如果传入一个 slice，如 double 函数，确可以改变数组的内容</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">double</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		s[i] = v * <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDouble</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	double(s)</span><br><span class="line">	fmt.Println(s) <span class="comment">// [2 4 6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>slice 的底层其实仍然是个数组，slice 这个数据结构持有了底层数组的指针，slice 长度和容量，如图所示<br><img src="/2022/%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3-Golang-Slice/slice.png" alt="slice.png"><br>真实的结构如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果创建一个slice <code>s := make([]byte, 5)</code>，其数据底层结构如图所示<br><img src="/2022/%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3-Golang-Slice/slice2.png" alt="slice2.png"><br>这个时候，我们很容易把 slice 就当成一个引用类型了。特别是有如 java 使用经验的人可能就会误用 slice</p>
<p>比如我们想把 slice 当作方法的参数传递，来为 slice 添加数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(s []<span class="type">string</span>, v <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	s = <span class="built_in">append</span>(s, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceTest</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="type">string</span></span><br><span class="line">    add(s, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出为 空</span></span><br></pre></td></tr></table></figure>
<p>乍一看会以为这段程序没问题。实际上我们的 add 函数并没有改变函数外的 s。我们仍然需要向下面这样传递至指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(s *[]<span class="type">string</span>, v <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	*s = <span class="built_in">append</span>(*s, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceTest</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="type">string</span></span><br><span class="line">    add(&amp;s, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 [a]</span></span><br></pre></td></tr></table></figure>
<p>为什么会如此呢？时刻理解 slice 本身并不是指针。当作参数传递时，我们其实已经再操作另外一个 slice 了。尽管方法里和方法外的 slice 可能指向了同一个数组（仔细回顾下 slice 的实际结构，想想这个赋值的过程）</p>
<p>再比如下面这段代码，我们要对一个list做 group by 的操作，得到一个 map，value 就是一个 slice，很容易得到思路 key 不存在时创建 slice，否则拿到这个 slice 并更新</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Pair <span class="keyword">struct</span> &#123;</span><br><span class="line">	U   <span class="type">string</span></span><br><span class="line">	Pid <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGroupBy</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	data := []Pair&#123;</span><br><span class="line">		&#123;U: <span class="string">&quot;a&quot;</span>, Pid: <span class="string">&quot;p1&quot;</span>&#125;,</span><br><span class="line">		&#123;U: <span class="string">&quot;a&quot;</span>, Pid: <span class="string">&quot;p2&quot;</span>&#125;,</span><br><span class="line">		&#123;U: <span class="string">&quot;a&quot;</span>, Pid: <span class="string">&quot;p3&quot;</span>&#125;,</span><br><span class="line">		&#123;U: <span class="string">&quot;b&quot;</span>, Pid: <span class="string">&quot;p2&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>)</span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> data &#123;</span><br><span class="line">		<span class="keyword">if</span> q, ok := m[p.U]; ok &#123;</span><br><span class="line">			q = <span class="built_in">append</span>(q, p.Pid) <span class="comment">// wrong line</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			m[p.U] = []<span class="type">string</span>&#123;p.Pid&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(m) <span class="comment">// map[a:[p1] b:[p2]]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到最终输出并不对。 </p>
<p>这里聪明的读者可能会说，因为 slice 扩容了，所以底层数组实际已经发生了改变。<br>没错，slice 如果发生扩容，如果 slice 原来持有 a1 的指针，扩容时会初始化一个新的数组 a2，容量是原来的一倍，并将 a1 中的元素都拷贝到 a2 中，slice 中数组指针也更新指向 a2，a1如无其他引用则等待 gc 回收。<br>那我们如果在初始化 map 中的 slice 时就给他一个足够大的 slice 确保不会发生扩容呢</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGroupBy</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>)</span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> data &#123;</span><br><span class="line">		<span class="keyword">if</span> q, ok := m[p.U]; ok &#123;</span><br><span class="line">			q = <span class="built_in">append</span>(q, p.Pid)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 初始化容量 5 的 slice，确保不扩容</span></span><br><span class="line">			s := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">            s = <span class="built_in">append</span>(s, p.Pid)</span><br><span class="line">            m[p.U] = s</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(m) <span class="comment">// map[a:[p1] b:[p2]]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现结果还是错的。<br>仔细审视代码发现，我们犯了一个教条式的错误 <code>q = append(q, p.Pid)</code>，更新数组的时候，我们很自然的用 q 去接收了。<br>再回头看看 slice 的结构是由三个字段组成的，<strong>数组指针、len <strong>和</strong> cap</strong>，这三个字段唯一构成了 slice 的一个视图，决定用户能访问到什么数据。在进行第二次迭代时，其实 q 和 m[‘a’] 持有的数组是同一个数组，并且数组内容也被更新了。但是由于我们用 q 直接去接受了 append 的返回值，所以我们只更新了 append 的 len 为 2，而原来 map[‘a’] 对应的 len 还是 1。所以对 map 中的 slice 中进行访问时只能访问到第一个数据。<br><img src="/2022/%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3-Golang-Slice/map-slice.png" alt="map-slice.png"><br>所以在这个例子里正确的做法应该是用 m[‘a’] 去接收 append 的返回值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> data &#123;</span><br><span class="line">	<span class="keyword">if</span> q, ok := m[p.U]; ok &#123;</span><br><span class="line">		m[p.U] = <span class="built_in">append</span>(q, p.Pid) </span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		m[p.U] = []<span class="type">string</span>&#123;p.Pid&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(m) <span class="comment">// map[a:[p1 p2 p3] b:[p2]]</span></span><br></pre></td></tr></table></figure>
<p>之所以犯了这种错误的原因是我们忽视了 slice 结构里的 len 和 cap，没有真正理解 append 返回值的含义。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://go.dev/blog/slices">Arrays, slices (and strings): The mechanics of ‘append’</a><br><a href="https://go.dev/blog/slices-intro">Go Slices: usage and internals</a><br><a href="https://geektutu.com/post/hpg-slice.html">切片(slice)性能及陷阱 | Go 语言高性能编程 | 极客兔兔</a></p>
<h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Pair</span><span class="params">(String u, String pid)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGroupBy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">pairs</span> <span class="operator">=</span> List.of(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;p1&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;p2&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;p3&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;p2&quot;</span>));</span><br><span class="line">    	<span class="type">var</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Pair p : data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(p.u)) &#123;</span><br><span class="line">                List&lt;String&gt; v = map.get(p.u);</span><br><span class="line">                v.add(p.pid);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(p.u, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of(p.pid)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(map); <span class="comment">// &#123;a=[p1, p2, p3], b=[p2]&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>几乎是一样代码，不同在于，因为 java 里是引用传递，所以对原始 list 的更新操作 <code>v.add(p.pid);</code>直接反映到了原始的 list 里，而 go 的却失效了。</p>
<p>用 java stream 实现更优雅的 groupby</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// by stream</span></span><br><span class="line"><span class="type">var</span> <span class="variable">map</span> <span class="operator">=</span> pairs.stream()</span><br><span class="line">        .collect(Collectors.groupingBy(</span><br><span class="line">                Pair::u,</span><br><span class="line">                Collectors.mapping(Pair::pid, Collectors.toList())));</span><br><span class="line"></span><br><span class="line"><span class="comment">// by map builtin method</span></span><br><span class="line"><span class="type">var</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Pair p : pairs) &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">v</span> <span class="operator">=</span> map.computeIfAbsent(p.u(), k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    v.add(p.pid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊 Mybatis 的 TypeHandler</title>
    <url>/2020/%E8%81%8A%E8%81%8A-Mybatis-%E7%9A%84-TypeHandler/</url>
    <content><![CDATA[<p>Mybatis 的 TypeHandler 是用来将 JavaBean 的属性与数据库中的字段值互相转换的，如果我们的 JavaBean 的属性是简单的属性如 String, Integer, Enum 等，我们一般不用关心 Mybatis 的 TypeHandler，但是如果我们需要将 JavaBean 的复杂对象作为一个字段值存储在数据表中，则需要自定义 TypeHandler 来处理值的映射，比较常见的处理是将复杂对象转换成一个 Json 字符串存储在数据库中，因此需要自定义 JsonTypeHandler，并且我们希望这个 JsonTypeHandler 能够处理泛型。</p>
<span id="more"></span>
<p>但是最近写一个代码的时候发现 Mybatis 对于 JavaBean 的一个 Map 属性去获取对应的 TypeHandler 时拿错了泛型对应的类型，促使我看了看 Mybatis 到底是如何加载 TypeHandler，如果获取 TypeHandler，如果获取的</p>
<h2 id="1-起因"><a href="#1-起因" class="headerlink" title="1 起因"></a>1 起因</h2><p>在一个 springboot 项目里，在 application.properteis 文件中配置了 typehandler 的 package</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mybatis.type-handlers-package=me.aki.demo.mybatisdemo.typehandler</span><br></pre></td></tr></table></figure>
<p>并定义了如下 JsonTypeHandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MappedJdbcTypes(JdbcType.VARCHAR)</span></span><br><span class="line"><span class="meta">@MappedTypes(&#123;Map.class, List.class, ChartType.class, GraphType.class, DatasourceMeta.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonTypeHandler</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">BaseTypeHandler</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JsonTypeHandler</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="type">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        ps.setString(i, serializeAsJsonString(parameter));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> deserializeFromJson(rs.getString(columnName), type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> deserializeFromJson(rs.getString(columnIndex), type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getNullableResult</span><span class="params">(CallableStatement cs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> deserializeFromJson(cs.getString(columnIndex), type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了一个 Mapper 类以及 getById 的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from chart where id = #&#123;chartId&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;type&quot;, property = &quot;type&quot;, typeHandler = ChartTypeHandler.class),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;graph_styles&quot;, property = &quot;graphStyles&quot;, typeHandler = GraphStylesTypeHandler.class),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;series_display_name&quot;, property = &quot;seriesDisplayName&quot;, typeHandler = JsonTypeHandler.class),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;stats&quot;, property = &quot;stats&quot;, typeHandler = StatsTypeHandler.class),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;headers&quot;, property = &quot;headers&quot;, typeHandler = HeadersTypeHandler.class),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;datasource_meta&quot;, property = &quot;datasourceMeta&quot;, typeHandler = DataSourceMetaTypeHandler.class),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;top_cells&quot;, property = &quot;topCells&quot;, typeHandler = TopCellsTypeHandler.class),</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">Chart <span class="title function_">getById</span><span class="params">(<span class="meta">@Param(&quot;chartId&quot;)</span> Integer chartId)</span>;</span><br></pre></td></tr></table></figure>
<p>然后调用 getById 的方法时报了如下的错误<br><img src="/2020/%E8%81%8A%E8%81%8A-Mybatis-%E7%9A%84-TypeHandler/error1.png" alt="error"><br>再 debug 一下发现是 mybatis 在设置 seriesDisplayName 这个属性时虽然使用了 JsonTypeHandler 但是泛型却错了<br><img src="/2020/%E8%81%8A%E8%81%8A-Mybatis-%E7%9A%84-TypeHandler/error2.png" alt="error"></p>
<h2 id="2-Mybatis-TypeHandler-的注册"><a href="#2-Mybatis-TypeHandler-的注册" class="headerlink" title="2 Mybatis TypeHandler 的注册"></a>2 Mybatis TypeHandler 的注册</h2><p>TypeHandler 的注册都是通过 TypeHandlerRegistry 这个类完成的，mybatis 已经预先定义了一些常用的 typehandler，需要特别注意的是 <code>TYPE_HANDLER_MAP</code> 和 <code>ALL_TYPE_HANDLERS_MAP</code>这两个属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; JDBC_TYPE_HANDLER_MAP = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;JdbcType, TypeHandler&lt;?&gt;&gt;(JdbcType.class);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; TYPE_HANDLER_MAP = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TypeHandler&lt;Object&gt; UNKNOWN_TYPE_HANDLER = <span class="keyword">new</span> <span class="title class_">UnknownTypeHandler</span>(<span class="built_in">this</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt; ALL_TYPE_HANDLERS_MAP = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>mybatis 中 javaType 与 jdbcType 是 多对多 的关系，对于 <code>String</code> 来说，可以映射的 jdbcType 有 <code>CHAR</code> <code>VARCHAR</code> 等等， 特别的，jdbcType 也可以指定为 null，用于为 javaType 对应的 jdbcType 未被用户定义的情况，如下是 <code>String</code> 对应的注册关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">register(String.class, JdbcType.CHAR, <span class="keyword">new</span> <span class="title class_">StringTypeHandler</span>());</span><br><span class="line">register(String.class, JdbcType.CLOB, <span class="keyword">new</span> <span class="title class_">ClobTypeHandler</span>());</span><br><span class="line">register(String.class, JdbcType.VARCHAR, <span class="keyword">new</span> <span class="title class_">StringTypeHandler</span>());</span><br><span class="line">register(String.class, JdbcType.LONGVARCHAR, <span class="keyword">new</span> <span class="title class_">ClobTypeHandler</span>());</span><br><span class="line">register(String.class, JdbcType.NVARCHAR, <span class="keyword">new</span> <span class="title class_">NStringTypeHandler</span>());</span><br><span class="line">register(String.class, JdbcType.NCHAR, <span class="keyword">new</span> <span class="title class_">NStringTypeHandler</span>());</span><br><span class="line">register(String.class, JdbcType.NCLOB, <span class="keyword">new</span> <span class="title class_">NClobTypeHandler</span>());</span><br></pre></td></tr></table></figure>
<p><code>TYPE_HANDLER_MAP</code> 维护了这样的多对多的关系，而 <code>ALL_TYPE_HANDLERS_MAP</code> 则是简单粗暴的将 handler 的 class 与 handler 本身对应起来，所以对于 <code>ALL_TYPE_HANDLERS_MAP</code> 来说，接收泛型的 typehandler 在注册的时候存在覆盖的情况。</p>
<p>当使用 springboot 的自动注入时，spring 在构建 SqlSession 时通过 SqlSessionFactoryBean 处理 mybatis 的属性并注册 typehandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSessionFactoryBean#buildSqlSessionFactory</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (hasLength(<span class="built_in">this</span>.typeHandlersPackage)) &#123;</span><br><span class="line">      String[] typeHandlersPackageArray = tokenizeToStringArray(<span class="built_in">this</span>.typeHandlersPackage,</span><br><span class="line">          ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line">      <span class="keyword">for</span> (String packageToScan : typeHandlersPackageArray) &#123;</span><br><span class="line">        <span class="comment">// 注册 handler</span></span><br><span class="line">        configuration.getTypeHandlerRegistry().register(packageToScan);</span><br><span class="line">        <span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">          LOGGER.debug(<span class="string">&quot;Scanned package: &#x27;&quot;</span> + packageToScan + <span class="string">&quot;&#x27; for type handlers&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>调用了 TypeHandlerRegistry 的 register 如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;?&gt; typeHandlerClass)</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">mappedTypeFound</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="type">MappedTypes</span> <span class="variable">mappedTypes</span> <span class="operator">=</span> typeHandlerClass.getAnnotation(MappedTypes.class);</span><br><span class="line">  <span class="keyword">if</span> (mappedTypes != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; javaTypeClass : mappedTypes.value()) &#123;</span><br><span class="line">      <span class="comment">// 对于注解了 MappedTypes 的，将 MappedTypes 的值作为 key 存入 TYPE_HANDLER_MAP 中</span></span><br><span class="line">      register(javaTypeClass, typeHandlerClass);</span><br><span class="line">      mappedTypeFound = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!mappedTypeFound) &#123;</span><br><span class="line">    register(getInstance(<span class="literal">null</span>, typeHandlerClass));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于泛型的 typehandler，初始化一个其泛型对应的 typehandler</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; TypeHandler&lt;T&gt; <span class="title function_">getInstance</span><span class="params">(Class&lt;?&gt; javaTypeClass, Class&lt;?&gt; typeHandlerClass)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (javaTypeClass != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Constructor&lt;?&gt; c = typeHandlerClass.getConstructor(Class.class);</span><br><span class="line">      <span class="keyword">return</span> (TypeHandler&lt;T&gt;) c.newInstance(javaTypeClass);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ignored) &#123;</span><br><span class="line">      <span class="comment">// ignored</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeException</span>(<span class="string">&quot;Failed invoking constructor for handler &quot;</span> + typeHandlerClass, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Constructor&lt;?&gt; c = typeHandlerClass.getConstructor();</span><br><span class="line">    <span class="keyword">return</span> (TypeHandler&lt;T&gt;) c.newInstance();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeException</span>(<span class="string">&quot;Unable to find a usable constructor for &quot;</span> + typeHandlerClass, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有 MappedTypes，则从 typeReference 中推测其类型</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(TypeHandler&lt;T&gt; typeHandler)</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">mappedTypeFound</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="type">MappedTypes</span> <span class="variable">mappedTypes</span> <span class="operator">=</span> typeHandler.getClass().getAnnotation(MappedTypes.class);</span><br><span class="line">  <span class="keyword">if</span> (mappedTypes != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; handledType : mappedTypes.value()) &#123;</span><br><span class="line">      register(handledType, typeHandler);</span><br><span class="line">      mappedTypeFound = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// @since 3.1.0 - try to auto-discover the mapped type</span></span><br><span class="line">  <span class="keyword">if</span> (!mappedTypeFound &amp;&amp; typeHandler <span class="keyword">instanceof</span> TypeReference) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TypeReference&lt;T&gt; typeReference = (TypeReference&lt;T&gt;) typeHandler;</span><br><span class="line">      register(typeReference.getRawType(), typeHandler);</span><br><span class="line">      mappedTypeFound = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="comment">// maybe users define the TypeReference with a different type and are not assignable, so just ignore it</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!mappedTypeFound) &#123;</span><br><span class="line">    register((Class&lt;T&gt;) <span class="literal">null</span>, typeHandler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果指定了 jdbcType，则在 TYPE_HANDLER_MAP 中的 value 中的 map 上 key 设置为 jdbcType，否则 key 设置为 null</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Type javaType, TypeHandler&lt;? extends T&gt; typeHandler)</span> &#123;</span><br><span class="line">  <span class="type">MappedJdbcTypes</span> <span class="variable">mappedJdbcTypes</span> <span class="operator">=</span> typeHandler.getClass().getAnnotation(MappedJdbcTypes.class);</span><br><span class="line">  <span class="keyword">if</span> (mappedJdbcTypes != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (JdbcType handledJdbcType : mappedJdbcTypes.value()) &#123;</span><br><span class="line">      register(javaType, handledJdbcType, typeHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mappedJdbcTypes.includeNullJdbcType()) &#123;</span><br><span class="line">      register(javaType, <span class="literal">null</span>, typeHandler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    register(javaType, <span class="literal">null</span>, typeHandler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终将 javaType，jdbcType，typehandler 写入 TYPE_HANDLER_MAP</span></span><br><span class="line"><span class="comment">// 将 handler.getClass() 与 handler 写入 ALL_TYPE_HANDLERS_MAP</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Type javaType, JdbcType jdbcType, TypeHandler&lt;?&gt; handler)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (javaType != <span class="literal">null</span>) &#123;</span><br><span class="line">    Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; map = TYPE_HANDLER_MAP.get(javaType);</span><br><span class="line">    <span class="keyword">if</span> (map == <span class="literal">null</span>) &#123;</span><br><span class="line">      map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;JdbcType, TypeHandler&lt;?&gt;&gt;();</span><br><span class="line">      TYPE_HANDLER_MAP.put(javaType, map);</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(jdbcType, handler);</span><br><span class="line">  &#125;</span><br><span class="line">  ALL_TYPE_HANDLERS_MAP.put(handler.getClass(), handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>register 方法跳转很多，总的来说要处理几件事情</p>
<ol>
<li>没有指定 MappedTypes 的情况下根据 handler 的 TypeReference 拿到其原始类型作为 javaType，指定了 MappedTypes 的情况下则使用 MappedTypes 作为其 javaType，并构造一个该 MappedType 对应的 handler</li>
<li>没有指定 jdbcType 的情况下，使用 null 作为 jdbcType，否则使用指定的 jdbcType</li>
</ol>
<p>需要注意的点是</p>
<ol>
<li>假设我们注册了多个 <code>xx entends BaseTypeHandler&lt;List&lt;T&gt;&gt;</code> ，那么他们 typeRerence 的 rawType 都是 List.class，这个 rawType 也就是 javaType 会作为 <code>TYPE_HANDLER_MAP</code> 中的 key，所以如果这多个 handler 的 jdbcType 也是一样的，那么这多个 handler 会在 <code>TYPE_HANDLER_MAP</code> 中被最后一个注册的覆盖</li>
<li><code>ALL_TYPE_HANDLERS_MAP</code> 对于泛型的 handler，存在相互覆盖，如上文定义的 JsonTypeHandler, 最后只会留下 <code>&#123;JsonTypeHandler, JsonTypeHandler&lt;DatasourceMeta&gt;&#125;</code> 这个键值对</li>
</ol>
<p>基本的注册流程就是这样子，下面我们来看下 Mybatis 是和做数据库值到 JavaBean 的转换的</p>
<h2 id="3-DB-Value-转换成-JavaBean"><a href="#3-DB-Value-转换成-JavaBean" class="headerlink" title="3 DB Value 转换成 JavaBean"></a>3 DB Value 转换成 JavaBean</h2><p>Mybatis 在启动时就会解析我们定义的 Mapper 类，以上文提到的 mapper 为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from chart where id = #&#123;chartId&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;type&quot;, property = &quot;type&quot;, typeHandler = ChartTypeHandler.class),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;graph_styles&quot;, property = &quot;graphStyles&quot;, typeHandler = GraphStylesTypeHandler.class),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;series_display_name&quot;, property = &quot;seriesDisplayName&quot;, typeHandler = JsonTypeHandler.class),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;stats&quot;, property = &quot;stats&quot;, typeHandler = StatsTypeHandler.class),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;headers&quot;, property = &quot;headers&quot;, typeHandler = HeadersTypeHandler.class),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;datasource_meta&quot;, property = &quot;datasourceMeta&quot;, typeHandler = DataSourceMetaTypeHandler.class),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;top_cells&quot;, property = &quot;topCells&quot;, typeHandler = TopCellsTypeHandler.class),</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">Chart <span class="title function_">getById</span><span class="params">(<span class="meta">@Param(&quot;chartId&quot;)</span> Integer chartId)</span>;</span><br></pre></td></tr></table></figure>
<p>我们用注解的方式定义了数据库中的 column 与 javaBean 的 property 如何映射，以及使用什么 handler。Mybatis 会通过 MapperAnnotaionBuilder 类完成对该方法的解析，并设置 column 与 property 的映射关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">applyResultMap</span><span class="params">(String resultMapId, Class&lt;?&gt; returnType, Arg[] args, Result[] results,    TypeDiscriminator discriminator)</span> &#123;</span><br><span class="line">  List&lt;ResultMapping&gt; resultMappings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  applyConstructorArgs(args, returnType, resultMappings);</span><br><span class="line">  applyResults(results, returnType, resultMappings);</span><br><span class="line">  <span class="type">Discriminator</span> <span class="variable">disc</span> <span class="operator">=</span> applyDiscriminator(resultMapId, returnType, discriminator);</span><br><span class="line">  <span class="comment">// TODO add AutoMappingBehaviour</span></span><br><span class="line">  assistant.addResultMap(resultMapId, returnType, <span class="literal">null</span>, disc, resultMappings, <span class="literal">null</span>);</span><br><span class="line">  createDiscriminatorResultMaps(resultMapId, returnType, discriminator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们一路跟踪 applyResults(results, returnType, resultMappings) 这个调用链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> MapperAnnotaionBuilder#applyResults</span><br><span class="line"><span class="number">2.</span> MapperBuilderAssistant#buildResultMapping</span><br><span class="line"><span class="number">3.</span> BaseBuilder#resolveTypeHandler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果我们的 result 注解里指定了 handler，则最终在这里根据 class 获取 handler</span></span><br><span class="line">  <span class="keyword">protected</span> TypeHandler&lt;?&gt; resolveTypeHandler(Class&lt;?&gt; javaType, Class&lt;? <span class="keyword">extends</span> <span class="title class_">TypeHandler</span>&lt;?&gt;&gt; typeHandlerType) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeHandlerType == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// javaType ignored for injected handlers see issue #746 for full detail</span></span><br><span class="line">    TypeHandler&lt;?&gt; handler = typeHandlerRegistry.getMappingTypeHandler(typeHandlerType);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// not in registry, create a new one</span></span><br><span class="line">      handler = typeHandlerRegistry.getInstance(javaType, typeHandlerType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>而 TypeHandlerRegistry#getMappingTypeHandler 如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TypeHandler&lt;?&gt; getMappingTypeHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">TypeHandler</span>&lt;?&gt;&gt; handlerType) &#123;</span><br><span class="line">  <span class="keyword">return</span> allTypeHandlersMap.get(handlerType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在我们定义了 result 里的 typehandler 时，是直接根据 typehandler 的 class 去 allTypeHandlersMap 拿 handler 的，而我们前文说过，allTypeHandlersMap 中的值是会被覆盖的，这就解释了为什么最后那个 mapper 方法会因为泛型错误而无法进行类型转换了。</p>
<p>如果我们删除 @Result(column &#x3D; “series_display_name”, property &#x3D; “seriesDisplayName”, typeHandler &#x3D; JsonTypeHandler.class) 中的 typeHandler 则程序能正常运行，正如上文中的 resolveTypeHandler，当我们删除 typeHandler 时，typeHandler 为 null，然后走了 <code>handler = typeHandlerRegistry.getInstance(javaType, typeHandlerType)</code> 这个逻辑，也就是会新建一个正确合适的 handler。</p>
<p>这是在程序初始化时完成的事情，对于标注了 @Result 的 property 会在 MapperAnnotaionBuilder 中完成 mapping 的映射，其他的属性则是在运行过程中完成映射的，我们跟踪一下代码的执行链路</p>
<ol>
<li>执行 query</li>
<li>DefaultResultSetHandler#handleReusltSets</li>
<li>DefaultResultSetHandler#handleResultSet</li>
<li>DefaultResultSetHandler#handleRowValues</li>
<li>DefaultResultSetHandler#getRowValue</li>
<li>DefaultResultSetHandler#applyAutomaticMappings</li>
<li>DefaultResultSetHandler#createAutomaticMappings</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultResultSetHandler#createAutomaticMappings</span><br><span class="line"></span><br><span class="line">    <span class="title function_">if</span> <span class="params">(property != <span class="literal">null</span> &amp;&amp; metaObject.hasSetter(property)</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (resultMap.getMappedProperties().contains(property)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">final</span> Class&lt;?&gt; propertyType = metaObject.getSetterType(property);</span><br><span class="line">      <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(propertyType, rsw.getJdbcType(columnName))) &#123;</span><br><span class="line">        <span class="comment">// 获取 typehandler 的关键代码</span></span><br><span class="line">        <span class="keyword">final</span> TypeHandler&lt;?&gt; typeHandler = rsw.getTypeHandler(propertyType, columnName);</span><br><span class="line">        autoMapping.add(<span class="keyword">new</span> <span class="title class_">UnMappedColumnAutoMapping</span>(columnName, property, typeHandler, propertyType.isPrimitive()));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        configuration.getAutoMappingUnknownColumnBehavior()</span><br><span class="line">            .doAction(mappedStatement, columnName, property, propertyType);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      configuration.getAutoMappingUnknownColumnBehavior()</span><br><span class="line">          .doAction(mappedStatement, columnName, (property != <span class="literal">null</span>) ? property : propertyName, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ResultSetWrapper 获取 TypeHandler 的关键代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResultSetWrapper#getTypeHandler</span><br><span class="line">  ...</span><br><span class="line">  <span class="type">JdbcType</span> <span class="variable">jdbcType</span> <span class="operator">=</span> getJdbcType(columnName);</span><br><span class="line">  handler = typeHandlerRegistry.getTypeHandler(propertyType, jdbcType);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">TypeHandlerRegistry#getTypeHandler</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; TypeHandler&lt;T&gt; <span class="title function_">getTypeHandler</span><span class="params">(Type type, JdbcType jdbcType)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ParamMap.class.equals(type)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; jdbcHandlerMap = getJdbcHandlerMap(type);</span><br><span class="line">    TypeHandler&lt;?&gt; handler = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (jdbcHandlerMap != <span class="literal">null</span>) &#123;</span><br><span class="line">      handler = jdbcHandlerMap.get(jdbcType);</span><br><span class="line">      <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">        handler = jdbcHandlerMap.get(<span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// #591</span></span><br><span class="line">        handler = pickSoleHandler(jdbcHandlerMap);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// type drives generics here</span></span><br><span class="line">    <span class="keyword">return</span> (TypeHandler&lt;T&gt;) handler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>也就是根据 propertyType 从 <code>TYPE_HANDLER_MAP</code> 中拿 jdbcHandlerMap，如果能不能根据 jdbcType 拿到 handler 则用 null 去拿 handler，至此，所有的 handler 的获取逻辑就理完了，总结一下获取 typehandler 分两步：</p>
<ol>
<li>如果定义 @Result，则在 Mybatis 初始化的时候就会配置好相应的 typehandler，且是从 <code>ALL_TYPE_HANDLERS_MAP</code> 取 handler，如果取到为空则新建一个 handler</li>
<li>对于未在 @Result 中定义的 property 是在运行时获取 handler 的，且是从 <code>TYPE_HANDLER_MAP</code> 中获取，取不到的话，这个值最终会被忽略</li>
</ol>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybaits</tag>
      </tags>
  </entry>
  <entry>
    <title>通过代理解决 git clone 和 homebrew 速度慢的问题</title>
    <url>/2019/%E8%A7%A3%E5%86%B3-git-clone-%E9%80%9F%E5%BA%A6%E6%85%A2/</url>
    <content><![CDATA[<p>实在忍不了在本地 git 的龟速了，虽然官网不挂代理也访问无碍，但是本地 git clone 总是只有几 KB，下载稍大的一点的 repo 不仅慢而且失败率飙升<br>解决方案自然是使 git clone 走代理了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global http.https://github.com.proxy socks5://127.0.0.1:1086</span><br><span class="line">git config --global https.https://github.com.proxy socks5://127.0.0.1:1086</span><br></pre></td></tr></table></figure>
<p>小水管下载也完美从几 KB 提升到了 500KB</p>
<span id="more"></span>
<p>由于我用的 ss，走的是 socks5 协议，并且端口号自定义为了 1086，所以使用如上配置</p>
<p>加速 homebrew 同样挂上代理：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export http_proxy=http://127.0.0.1:1087;export https_proxy=http://127.0.0.1:1087;</span><br><span class="line">brew update &amp;&amp; brew upgrade</span><br></pre></td></tr></table></figure>

<p>使用时一定要请看代理协议与端口号。。。最开始一只把 http 的端口号也当成了 1086 导致一直没啥速度</p>
<p>参考：<br><a href="https://www.zhihu.com/question/27159393">zhihu: git clone…</a></p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
